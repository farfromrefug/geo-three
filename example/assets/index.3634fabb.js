var Ka=Object.defineProperty,Ja=Object.defineProperties;var eo=Object.getOwnPropertyDescriptors;var It=Object.getOwnPropertySymbols;var Qi=Object.prototype.hasOwnProperty,Ki=Object.prototype.propertyIsEnumerable;var Ji=(t,e,i)=>e in t?Ka(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,ne=(t,e)=>{for(var i in e||(e={}))Qi.call(e,i)&&Ji(t,i,e[i]);if(It)for(var i of It(e))Ki.call(e,i)&&Ji(t,i,e[i]);return t},Ke=(t,e)=>Ja(t,eo(e));var ea=(t,e)=>{var i={};for(var a in t)Qi.call(t,a)&&e.indexOf(a)<0&&(i[a]=t[a]);if(t!=null&&It)for(var a of It(t))e.indexOf(a)<0&&Ki.call(t,a)&&(i[a]=t[a]);return i};import{M as zt,G as to,T as ue,R as Nt,L as Te,B as Mt,F as re,V as Ne,a as S,b as vi,c as wi,d as Ht,e as io,Q as ao,t as le,f as Je,g as Bt,N as et,h as ta,D as oo,U as so,C as yt,i as no,S as ia,j as ro,k as lo,l as co,m as aa,P as ho,n as uo,o as Ft,p as fo,q as mo,r as po,s as go,u as tt,v as vo,W as wo,w as xo,x as Mo,E as yo,y as bo,H as Eo,z as To,K as ge,A as Do,I as Lo,J as Ro,O as Po,X as So,Y as Co,Z as Oo,_ as Ao,$ as oa,a0 as _o,a1 as Io,a2 as zo}from"./vendor.10cf4db9.js";const No=function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))a(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const n of s.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&a(n)}).observe(document,{childList:!0,subtree:!0});function i(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerpolicy&&(s.referrerPolicy=o.referrerpolicy),o.crossorigin==="use-credentials"?s.credentials="include":o.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function a(o){if(o.ep)return;o.ep=!0;const s=i(o);fetch(o.href,s)}};No();(()=>{const t=["_imageBitmapOptions","resizeWidth","resizeHeight","resizeQuality","imageOrientation"],e=["_Blob","_ImageData","_SVGBlob","_SVGImageElement"],i=["resizeWidth","resizeHeight","resizeQuality","imageOrientation","premultiplyAlpha","colorSpaceConversion"],a={ResizeQuality:["pixelated","low","medium","high"],ImageOrientation:["none","flipY"]},o={COMMON_HEADER:"Failed to execute 'createImageBitmap': ",INVALID_STATE_IMAGE:"Provided image was in an invalid state.",ARGUMENT_COUNT_1:"At least one argument is required.",ARGUMENT_COUNT_N:"%s is not a valid argument count for any overload",CROP_RECT_ZERO:"The crop rect width passed to createImageBitmap must be nonzero",ALLOCATION_FAILED:"The ImageBitmap could not be allocated.",INVALID_SOURCE:"Argument 1 could not be converted to any of: HTMLImageElement, SVGImageElement, HTMLCanvasElement, HTMLVideoElement, ImageBitmap, Blob, CanvasRenderingContext2D, ImageData.",ENUM:"'%v' is not a valid value for enumeration %e",ALLOCATION:"The ImageBitmap couldn't be allocated."},s=["HTMLImageElement","SVGImageElement","HTMLVideoElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap"],n="http://www.w3.org/2000/svg",r="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";function l(m){try{return m.slice(0,0),!1}catch{return!0}}const c=new Int32Array(1);function h(m){return Number.isFinite(m)?(c[0]=m,c[0]):NaN}function p(m){const y=h(m);if(isNaN(y))throw new TypeError("Invalid long value");return y}function u(m,y){const b=Object.assign(document.createElement("canvas"),{width:m,height:y}).getContext("2d");if(m&&y&&!function(R){if(R.isContextLost)return R.translate(0,0),!R.isContextLost();let A=!1;try{R.fillRect(0,0,1,1),A=R.getImageData(0,0,1,1).data[3]!==0}finally{return R.clearRect(0,0,1,1),A}}(b))throw new DOMException(o.ALLOCATION,"InvalidStateError");return b}function w(m){return y=>{const b=globalThis[y];return b&&m instanceof b}}const x=globalThis.createImageBitmap,g=!!x&&((...m)=>x.call(globalThis,...m));function T(m){const y=new Image;return y.src=m,new Promise((b,R)=>{y.onload=A=>{W(y),b(y)},y.onerror=A=>{const k=new DOMException(o.INVALID_STATE_IMAGE,"InvalidStateError");R(k)}})}function f(m){return T(m.getAttribute("href")||m.getAttributeNS("http://www.w3.org/1999/xlink","href"))}const v=o.COMMON_HEADER;function M(m,y,b){const R=a[b],A=m[y];if(A!==void 0&&!R.includes(A)){const k=o.ENUM.replace("%v",A).replace("%e",b);throw new TypeError(k)}}function L(m,...y){let b,[R,A,k,de]=y.map(h);const te=(y.length===1?y[0]:y[4])||{},Ie="resizeWidth"in te&&p(te.resizeWidth),Ee="resizeHeight"in te&&p(te.resizeHeight);M(te,"resizeQuality","ResizeQuality"),M(te,"imageOrientation","ImageOrientation");const ae=arguments.length;if(!ae)throw new TypeError(v+o.ARGUMENT_COUNT_1);if(ae>2&&ae<5)throw o.ARGUMENT_COUNT_N.replace("%s",ae),new TypeError(v+err_count_msg);if(ae>=5){if(!k||!de)throw new RangeError(v+o.CROP_RECT_ZERO);R=R||0,A=A||0,b={sx:R,sy:A,sw:k,sh:de}}if(Ie===0||Ee===0){const ft=v+o.ALLOCATION_FAILED;throw new DOMException(ft,"InvalidStateError")}return ne({cropRect:b},te)}function D(m,...y){const b=y.length;return m.has("_imageBitmapOptions")&&[2,6].includes(b)?y.slice(0,b-1):y}function he(m){const y=w(m);return y("HTMLImageElement")?{width:m.naturalWidth,height:m.naturalHeight}:y("HTMLVideoElement")?{width:m.videoWidth,height:m.videoHeight}:y("SVGImageElement")?{width:NaN,height:NaN}:y("HTMLCanvasElement")||y("OffscreenCanvas")||y("ImageBitmap")||y("ImageData")?m:{width:NaN,height:NaN}}function G(m,y){const b=function(hi,se){const{width:qe,height:ze}=he(hi),{resizeWidth:Xa,resizeHeight:qa}=se,di=se.cropRect||{sx:0,sy:0,sw:qe,sh:ze},ui={dx:0,dy:0,dw:Xa||Math.abs(di.sw),dh:qa||Math.abs(di.sh)},pt=function(Ya,Qa,{sx:gt,sy:vt,sw:Ye,sh:Qe},{dx:fi,dy:mi,dw:wt,dh:xt}){Ye<0&&(gt+=Ye,Ye=Math.abs(Ye)),Qe<0&&(vt+=Qe,Qe=Math.abs(Qe)),wt<0&&(fi+=wt,wt=Math.abs(wt)),xt<0&&(mi+=xt,xt=Math.abs(xt));const pi=Math.max(gt,0),$i=Math.min(gt+Ye,Ya),gi=Math.max(vt,0),Xi=Math.min(vt+Qe,Qa),qi=wt/Ye,Yi=xt/Qe;return{sx:pi,sy:gi,sw:$i-pi,sh:Xi-gi,dx:gt<0?fi-gt*qi:fi,dy:vt<0?mi-vt*Yi:mi,dw:($i-pi)*qi,dh:(Xi-gi)*Yi}}(qe,ze,di,ui);return pt.resizeQuality=se.resizeQuality,pt.flipY=se.imageOrientation==="flipY",pt.width=ui.dw,pt.height=ui.dh,pt}(m,y);he(m);const{sx:R,sy:A,sw:k,sh:de,dx:te,dy:Ie,dw:Ee,dh:ae,flipY:ft,resizeQuality:mt}=b,oe=u(b.width,b.height),Xe=oe.canvas;return mt==="pixelated"?oe.imageSmoothingEnabled=!1:mt&&(oe.imageSmoothingQuality=mt),oe.drawImage(m,R,A,k,de,te,Ie,Ee,ae),ft&&(oe.globalCompositeOperation="copy",oe.setTransform(1,0,0,-1,0,Xe.height),oe.drawImage(Xe,0,0)),Xe}async function Z(m,y){const b=globalThis.URL.createObjectURL(m),R=await T(b);return globalThis.URL.revokeObjectURL(m),G(R,y)}async function z(m,y){const{resizeWidth:b,resizeHeight:R,resizeQuality:A,imageOrientation:k}=y,de=y.cropRect||{},te=de.sx||0,Ie=de.sy||0,Ee=de.sw||m.width,ae=de.sh||m.height,ft=Ee<0?-1*Ee-te:-te,mt=ae<0?-1*ae-Ie:-Ie,oe=u(Math.abs(Ee),Math.abs(ae));oe.putImageData(m,ft,mt,te,Ie,Ee,ae);const Xe=k==="flipY",hi=b||Xe;let se;b?(se=u(b,R),A==="pixelated"?se.imageSmoothingEnabled=!1:se.imageSmoothingQuality=A):(se=oe,oe.globalCompositeOperation="copy");const qe=oe.canvas,ze=se.canvas;return Xe&&se.setTransform(1,0,0,-1,0,ze.height),hi&&se.drawImage(qe,0,0,qe.width,qe.height,0,0,ze.width,ze.height),ze}function I(){const m=o.COMMON_HEADER+o.INVALID_STATE_IMAGE;throw new DOMException(m,"InvalidStateError")}function W(m){const y=w(m);if(y("HTMLCanvasElement")||y("OffscreenCanvas")||y("ImageBitmap"))m.width!==0&&m.height!==0||I();else if(y("HTMLImageElement")||y("HTMLVideoElement")||y("SVGImageElement")){const{width:b,height:R}=he(m);b!==0&&R!==0||I();let A=!1;try{A=!u(0,0).createPattern(m,"no-repeat")}catch{return"maybe"}A&&I()}return!0}let $=!1;const K=function(){if(!g){const R=t.concat(e);return new Set(R)}const m=[_e()],y=new Set(m.flat()),b=t.filter(R=>!y.has(R));return new Set(b)}(),ie=async function(){if(!g)return $=!0,K;const m=[dt(),ut(),Ga(),Za()],y=await Promise.all(m),b=new Set(y.flat());return e.filter(R=>!b.has(R)).forEach(R=>K.add(R)),$=!0,K}();function _e(){const m=[],y={};return i.forEach(b=>{Object.defineProperty(y,b,{get(){m.push(b)}})}),g(new ImageData(1,1),y).then(b=>b.close()).catch(()=>{}),m.length&&m.push("_imageBitmapOptions"),m}async function dt(){const m=[],y=await fetch(r).then(b=>b.ok&&b.blob());try{(await g(y)).width===1&&m.push("_Blob")}catch(b){console.log(b)}return m}async function ut(){const m=[],y=function(b,R){try{return new ImageData(1,1)}catch{return create2dContext(0,0).createImageData(1,1)}}();try{(await g(y)).width===1&&m.push("_ImageData")}catch{}return m}async function Ga(){const m=[],y=new Blob([`<svg width="1" height="1" xmlns="${n}">
      <rect width="1" height="1"/>
    </svg>`],{type:"image/svg+xml"});try{(await g(y)).width===1&&m.push("_SVGBlob")}catch{}return m}async function Za(){const m=[];if(!("SVGImageElement"in globalThis))return m;const y=k=>new Promise(de=>setTimeout(de,k)),b=document.createElementNS(n,"image");b.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",r);const R=()=>{try{return W(b),!1}catch{return!0}};let A=0;do await y(10);while(R()&&++A<300);try{await g(b),m.push("_SVGImageElement")}catch(k){console.error(k)}return m}function Wa(m,y,b){const R=w(b);return R("Blob")&&(m.has("_Blob")||(b==null||b.type,m.has("_SVGBlob")))?!0:!(!R("ImageData")||!m.has("_ImageData"))||!(!R("SVGImageElement")||!m.has("_SVGImageElement"))||!!Object.keys(y).some(A=>m.has(A))}function ja(m,y){if($)return!1;const b=w(m);return["Blob","ImageData","SVGImageElement"].some(b)}const _t=m=>Object.getOwnPropertyDescriptor(HTMLCanvasElement.prototype,m);function ci(){throw new TypeError("Illegal Constructor")}function $a(m){return m instanceof globalThis.ImageBitmap?m:g?g(m):function(y){return y instanceof HTMLCanvasElement||(y=G(y)),Object.setPrototypeOf(y,ci.prototype),y}(m)}ci.prototype=Object.create({close(){_t("width").set.call(this,0),_t("height").set.call(this,0)},get width(){return _t("width").get.call(this)},get height(){return _t("height").get.call(this)},get[Symbol.toStringTag](){return"ImageBitmap"}}),g||(globalThis.ImageBitmap=ci),globalThis.createImageBitmap=async function(m,...y){const b=L(...arguments),R=ja(m)?await ie:K;if(R.size===0)return g(...arguments);if(g&&!Wa(R,b,m))return g(...D(R,...arguments));const A=w(m);let k;if(s.some(A)?(W(m),A("SVGImageElement")&&(m=await f(m)),A("HTMLImageElement")&&(m.naturalWidth||m.naturalHeight||b.resizeWidth&&b.resizeHeight||I()),k=G(m,b)):A("Blob")?k=await Z(m,b):A("ImageData")&&(l(m.data.buffer)&&I(),k=await z(m,b)),!k)throw new TypeError(o.INVALID_SOURCE);return await $a(k)},globalThis.createImageBitmap._original=g})();class bt{static createOffscreenCanvas(e,i){try{return new OffscreenCanvas(e,i)}catch{let o=document.createElement("canvas");return o.width=e,o.height=i,o}}}const Ut=new Map;function Ho(t,e,i){return Ut.get(`${t}_${e}_${i}`)}function Bo(){Ut.clear()}function Et(t){var e;t.childrenCache&&(t.childrenCache.forEach(Et),t.childrenCache=null,t.nodesLoaded=0),((e=t.children)==null?void 0:e.length)>0&&(t.children.forEach(i=>i instanceof P&&Et(i)),t.children=[]),t.dispose()}const De=class extends zt{constructor(t=null,e=null,i=De.root,a=0,o=0,s=0,n=null,r=null){super(n,r);this.mapView=null,this.parentNode=null,this.textureLoaded=!1,this.nodesLoaded=0,this.subdivided=!1,this.childrenCache=null,this.mapView=e,this.parentNode=t,this.location=i,this.level=a,this.x=o,this.y=s,Ut.set(`${a}_${o}_${s}`,this);const l=e.nodeShouldAutoLoad();this.isMesh=!1,this.matrixAutoUpdate=!1,this.isTextureReady=l,this.objectsHolder=new to,this.objectsHolder.visible=!l,this.add(this.objectsHolder),l&&this.initialize()}initialize(){}dispose(){this.mapView.provider.cancelTile(this.level,this.x,this.y),this.geometry=null,this.material=null,this.objectsHolder=null,this.mapView=null,this.parentNode=null,Ut.delete(`${this.level}_${this.x}_${this.y}`)}createChildNodes(){}subdivide(){const t=this.mapView,e=Math.min(t.provider.actualMaxZoom,t.heightProvider.actualMaxZoom);this.subdivided||this.level+1>e||(this.subdivided=!0,this.childrenCache!==null?(this.childrenCache.forEach(i=>{i instanceof De&&(i.textureLoaded?i.show():i.hide())}),this.children=this.childrenCache,this.nodesLoaded>=De.childrens&&this.hide()):this.createChildNodes())}simplify(t,e){var i,a,o,s;!this.subdivided||(this.subdivided=!1,this.mapView.lowMemoryUsage||t>e/100||((i=this.parentNode)==null?void 0:i.subdivided)&&((o=(a=this.parentNode)==null?void 0:a.parentNode)==null?void 0:o.subdivided)?(((s=this.children)==null?void 0:s.length)&&(this.children.forEach(n=>n instanceof De&&Et(n)),this.children=[]),this.childrenCache&&(this.childrenCache.forEach(n=>n instanceof De&&Et(n)),this.childrenCache=null,this.nodesLoaded=0)):(this.childrenCache=this.children,this.childrenCache&&this.childrenCache.forEach(n=>{n.childrenCache&&n.children.length>1&&(n.childrenCache=null,n.nodesLoaded=0)})),this.show(),this.didSimplify())}didSimplify(){this.children=[this.objectsHolder]}show(){this.isMesh=!0,this.objectsHolder.visible=!0}isVisible(){return this.isMesh}hide(){this.isMesh=!1,this.objectsHolder.visible=!1}onTextureImage(t){if(t){const e=new ue(t);e.generateMipmaps=!1,e.format=Nt,e.magFilter=Te,e.minFilter=Te,e.needsUpdate=!0,this.material.map=e}}setMaterialValues(t){const e=this.material.userData;Object.keys(t).forEach(i=>{e.hasOwnProperty(i)&&(e[i].value=t[i])})}loadTexture(){if(!this.isTextureReady)return this.isTextureReady=!0,this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>this.onTextureImage(t)).catch(()=>{const t=bt.createOffscreenCanvas(1,1),e=t.getContext("2d");e.fillStyle="#FF0000",e.fillRect(0,0,1,1);const i=new ue(t);i.generateMipmaps=!1,i.needsUpdate=!0,this.material.map=i}).catch(t=>{console.error("error fetching image",t)}).finally(()=>{!this.mapView||(this.textureLoaded=!0,this.nodeReady())})}nodeReady(){this.subdivided||this.show();const t=this.parentNode;t!==null?(t.nodesLoaded++,t.nodesLoaded>=De.childrens&&(t.children.forEach((e,i)=>{e instanceof De&&(e.subdivided?e.hide():e.show())}),t.subdivided===!0&&t.hide())):this.subdivided||this.show(),this.mapView.onNodeReady(this)}getNeighborsDirection(t){return null}getNeighbors(){return[]}};let P=De;P.baseGeometry=null;P.baseScale=null;P.childrens=4;P.root=-1;P.topLeft=0;P.topRight=1;P.bottomLeft=2;P.bottomRight=3;class fe extends Mt{constructor(e=1,i=1,a=1,o=1,s={skirt:!1,skirtDepth:10,uvs:!0}){super();const n=[],r=[],l=s.uvs?[]:void 0;fe.buildPlane(e,i,a,o,n,r,l),s.skirt&&fe.buildSkirt(e,i,a,o,s.skirtDepth,n,r,l),this.setIndex(n),this.setAttribute("position",new re(r,3)),s.uvs&&this.setAttribute("uv",new re(l,2))}static buildPlane(e=1,i=1,a=1,o=1,s,n,r){const l=e/2,c=i/2,h=a+1,p=o+1,u=e/a,w=i/o;for(let x=0;x<p;x++){const g=x*w-c;for(let T=0;T<h;T++){const f=T*u-l;n.push(f,0,g),r&&r.push(T/a,1-x/o)}}for(let x=0;x<o;x++)for(let g=0;g<a;g++){const T=g+h*x,f=g+h*(x+1),v=g+1+h*(x+1),M=g+1+h*x;s.push(T,f,M,f,v,M)}}static buildSkirt(e=1,i=1,a=1,o=1,s,n,r,l){const c=e/2,h=i/2,p=a+1,u=o+1,w=e/a,x=i/o;let g=r.length/3;for(let f=0;f<p;f++){const v=f*w-c,M=-h;r.push(v,-s,M),l&&l.push(f/a,1)}for(let f=0;f<a;f++){const v=f,M=f+1,L=f+g,D=f+g+1;n.push(M,L,v,M,D,L)}g=r.length/3;for(let f=0;f<p;f++){const v=f*w-c,M=o*x-h;r.push(v,-s,M),l&&l.push(f/a,0)}let T=p*u-a-1;for(let f=0;f<a;f++){const v=T+f,M=T+f+1,L=f+g,D=f+g+1;n.push(v,L,M,L,D,M)}g=r.length/3;for(let f=0;f<u;f++){const v=f*x-h,M=-c;r.push(M,-s,v),l&&l.push(0,1-f/o)}for(let f=0;f<o;f++){const v=f*u,M=(f+1)*u,L=f+g,D=f+g+1;n.push(v,L,M,L,D,M)}g=r.length/3;for(let f=0;f<u;f++){const v=f*x-h,M=a*w-c;r.push(M,-s,v),l&&l.push(1,1-f/o)}for(let f=0;f<o;f++){const v=f*u+o,M=(f+1)*u+o,L=f+g,D=f+g+1;n.push(M,L,v,M,D,L)}}}const He=class{static get(t,e){navigator.geolocation.getCurrentPosition(function(i){t(i.coords,i.timestamp)},e)}static datumsToSpherical(t,e,i,a=1){const o=e*He.EARTH_ORIGIN/180;let s=Math.log(Math.tan((90+t)*Math.PI/360))/(Math.PI/180);return s=s*He.EARTH_ORIGIN/180,i?i.set(o*a,s*a):new Ne(o*a,s*a)}static sphericalToDatums(t,e){const i=t/He.EARTH_ORIGIN*180;let a=e/He.EARTH_ORIGIN*180;return a=180/Math.PI*(2*Math.atan(Math.exp(a*Math.PI/180))-Math.PI/2),{lat:Math.round(a*1e4)/1e4,lon:Math.round(i*1e4)/1e4}}static quadtreeToDatums(t,e,i){const a=Math.pow(2,t),o=e/a*360-180,s=Math.atan(Math.sinh(Math.PI*(1-2*i/a)));return{lat:180*(s/Math.PI),lon:o}}};let N=He;N.EARTH_RADIUS=6378137;N.EARTH_PERIMETER=2*Math.PI*He.EARTH_RADIUS;N.EARTH_ORIGIN=He.EARTH_PERIMETER/2;const xi=class extends P{constructor(t=null,e=null,i=P.root,a=0,o=0,s=0){super(t,e,i,a,o,s,xi.geometry,new vi({wireframe:!1}));this.matrixAutoUpdate=!1}initialize(){return this.loadTexture()}createChildNodes(){const t=this.level+1,e=this.x*2,i=this.y*2,a=Object.getPrototypeOf(this).constructor;let o=new a(this,this.mapView,P.topLeft,t,e,i);o.scale.set(.5,1,.5),o.position.set(-.25,0,-.25),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0),o=new a(this,this.mapView,P.topRight,t,e+1,i),o.scale.set(.5,1,.5),o.position.set(.25,0,-.25),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0),o=new a(this,this.mapView,P.bottomLeft,t,e,i+1),o.scale.set(.5,1,.5),o.position.set(-.25,0,.25),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0),o=new a(this,this.mapView,P.bottomRight,t,e+1,i+1),o.scale.set(.5,1,.5),o.position.set(.25,0,.25),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0)}raycast(t,e){return this.isVisible()?super.raycast(t,e):!1}};let Me=xi;Me.geometry=new fe(1,1,1,1,{skirt:!1});Me.baseGeometry=xi.geometry;Me.baseScale=new S(N.EARTH_PERIMETER,1,N.EARTH_PERIMETER);class Fo extends Mt{constructor(e=1,i=1,a=1,o=1,s=!1,n=10,r=null,l=!0){super();const c=[],h=[],p=[],u=[];fe.buildPlane(e,i,a,o,c,h,u);const w=r.data;for(let x=0,g=0;x<w.length&&g<h.length;x+=4,g+=3){const T=w[x],f=w[x+1],v=w[x+2],M=(T*65536+f*256+v)*.1-1e4;h[g+1]=M}s&&fe.buildSkirt(e,i,a,o,n,c,h,u),this.setIndex(c),this.setAttribute("position",new re(h,3)),this.setAttribute("normal",new re(p,3)),this.setAttribute("uv",new re(u,2)),l&&this.computeNormals(a,o)}computeNormals(e,i){const a=this.getAttribute("position");if(a!==void 0){let o=this.getAttribute("normal");const s=i*e;for(let g=0;g<s;g++)o.setXYZ(g,0,0,0);const n=new S,r=new S,l=new S,c=new S,h=new S,p=new S,u=new S,w=new S,x=i*e*6;for(let g=0;g<x;g+=3){const T=this.index.getX(g+0),f=this.index.getX(g+1),v=this.index.getX(g+2);n.fromBufferAttribute(a,T),r.fromBufferAttribute(a,f),l.fromBufferAttribute(a,v),u.subVectors(l,r),w.subVectors(n,r),u.cross(w),c.fromBufferAttribute(o,T),h.fromBufferAttribute(o,f),p.fromBufferAttribute(o,v),c.add(u),h.add(u),p.add(u),o.setXYZ(T,c.x,c.y,c.z),o.setXYZ(f,h.x,h.y,h.z),o.setXYZ(v,p.x,p.y,p.z)}this.normalizeNormals(),o.needsUpdate=!0}}}const ve=class extends P{constructor(t=null,e=null,i=P.root,a=0,o=0,s=0,n=ve.geometry,r=new wi({color:0,emissive:16777215})){super(t,e,i,a,o,s,n,r);this.heightLoaded=!1,this.heightListeners=[],this.matrixAutoUpdate=!1;const l=e.nodeShouldAutoLoad();this.isHeightReady=l}initialize(){return super.initialize(),Promise.all([this.loadTexture(),this.loadHeightGeometry()])}dispose(){this.mapView.heightProvider.cancelTile(this.level,this.x,this.y),super.dispose()}onTextureImage(t){if(t){const e=new ue(t);e.generateMipmaps=!1,e.format=Nt,e.magFilter=Te,e.minFilter=Te,e.needsUpdate=!0,this.material.map=e}}loadTexture(){if(!this.isTextureReady)return this.isTextureReady=!0,this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>this.onTextureImage(t)).finally(()=>{this.textureLoaded=!0,this.nodeReady()})}nodeReady(){!this.mapView||!this.heightLoaded||!this.textureLoaded||super.nodeReady()}createChildNodes(){const t=this.level+1;var e=Object.getPrototypeOf(this);const i=this.x*2,a=this.y*2;let o=new e.constructor(this,this.mapView,P.topLeft,t,i,a);o.scale.set(.5,1,.5),o.position.set(-.25,0,-.25),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0),o=new e.constructor(this,this.mapView,P.topRight,t,i+1,a),o.scale.set(.5,1,.5),o.position.set(.25,0,-.25),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0),o=new e.constructor(this,this.mapView,P.bottomLeft,t,i,a+1),o.scale.set(.5,1,.5),o.position.set(-.25,0,.25),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0),o=new e.constructor(this,this.mapView,P.bottomRight,t,i+1,a+1),o.scale.set(.5,1,.5),o.position.set(.25,0,.25),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0)}async handleParentOverZoomTile(t){throw new Error("not implemented")}async loadHeightGeometry(){if(this.isHeightReady||!this.mapView)return;this.isHeightReady=!0;const t=this.mapView.heightProvider;if(t===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");try{const e=this.level;if(e>t.maxZoom&&e<=t.maxZoom+t.maxOverZoom){const i=this.parentNode;if(i.heightLoaded)await this.handleParentOverZoomTile();else{const a=new Promise(o=>{i.heightListeners.push(()=>this.handleParentOverZoomTile(o))});i.isHeightReady||i.loadHeightGeometry(),await a}}else{const i=await this.mapView.heightProvider.fetchTile(e,this.x,this.y);await this.onHeightImage(i)}}finally{this.mapView&&(this.heightLoaded=!0,this.heightListeners.forEach(e=>e()),this.nodeReady()),this.heightListeners=[]}}onHeightImage(t){const e=bt.createOffscreenCanvas(ve.geometrySize+1,ve.geometrySize+1),i=e.getContext("2d");i.imageSmoothingEnabled=!1,i.drawImage(t,0,0,ve.tileSize,ve.tileSize,0,0,e.width,e.height);const a=i.getImageData(0,0,e.width,e.height),o=new Fo(1,1,ve.geometrySize,ve.geometrySize,!0,10,a,!0);this.geometry=o}raycast(t,e){return this.isVisible()?super.raycast(t,e):!1}};let ce=ve;ce.tileSize=256;ce.geometrySize=16;ce.geometry=new fe(1,1,ve.geometrySize,ve.geometrySize);ce.baseGeometry=Me.geometry;ce.BASE_SCALE=new S(N.EARTH_PERIMETER,1,N.EARTH_PERIMETER);const sa=new Ht,na=new S,Mi=new io,yi=new S;class Uo{constructor(){this.subdivideDistance=120,this.simplifyDistance=400,this.testCenter=!0,this.pointOnly=!1,this.toHandle=new Set,this.handled=new Set}isChildReady(e){return e.isTextureReady&&(!(e instanceof ce)||e.isHeightReady)}handleNode(e,i,a,o,s,n=!1,r=!0,l=!0){if(!(e instanceof P)||i.has(e)||!e.mapView)return;i.add(e),e.getWorldPosition(yi);var c=na.distanceTo(yi);const h=c/Math.pow(2,20-e.level);if(n=n||(this.pointOnly?Mi.containsPoint(yi):Mi.intersectsObject(e)),r&&s>e.level&&h<this.subdivideDistance&&n){e.subdivide();const p=e.children;if(p)for(let u=0;u<p.length;u++){const w=p[u];w instanceof P&&this.handleNode(w,i,a,o,s,!1,!0,!1)}e.hide()}else if(l&&(e.level>s||(!n||o<e.level)&&h>this.simplifyDistance)&&e.parentNode){const p=e.parentNode;p.simplify(h,a.far),this.handleNode(p,i,a,o,s,!1,!1,!0)}else(!l&&!r||n||h<this.simplifyDistance)&&o<=e.level&&c<a.far&&(this.isChildReady(e)||e.initialize())}getChildrenToTraverse(e){const i=this.toHandle;i.clear();function a(o){o instanceof P&&!o.subdivided?i.add(o):o.children.forEach(s=>{o instanceof P&&a(s)})}return a(e),i}updateLOD(e,i,a,o,s=!1){if(!s&&this.lastMatrix&&this.lastMatrix.equals(i.matrixWorldInverse))return;this.lastMatrix||(this.lastMatrix=new Ht),this.lastMatrix.copy(i.matrixWorldInverse),sa.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Mi.setFromProjectionMatrix(sa),i.getWorldPosition(na);const n=e.provider.minZoom,r=e.provider.maxZoom+e.provider.maxOverZoom,l=this.getChildrenToTraverse(e.children[0]);let c=this.handled;l.forEach(h=>this.handleNode(h,c,i,n,r)),c.clear()}}class Be{constructor(e,i){this.fulfilled=!1,this.rejected=!1,this.called=!1,this.cancelRunner=i;const a=s=>{this.fulfilled=!0,this.value=s,typeof this.onResolve=="function"&&(this.onResolve(this.value),this.called=!0)},o=this.rejectHandler=s=>{this.rejected=!0,this.value=s,typeof this.onReject=="function"&&(this.onReject(this.value),this.called=!0)};try{e(a,o)}catch(s){o(s)}}cancel(){return this.cancelRunner?(this.cancelRunner()||this.rejectHandler("cancelled"),!0):!1}then(e){return this.onResolve=e,this.fulfilled&&!this.called&&(this.called=!0,this.onResolve(this.value)),this}catch(e){return this.onReject=e,this.rejected&&!this.called&&(this.called=!0,this.onReject(this.value)),this}finally(e){return this}static resolve(e){return new Be(function(a,o){a(e)})}static reject(e){return new Be(function(a,o){o(e)})}static all(e){const i=[],a=[];function o(s,n){e.forEach((r,l)=>r.then(c=>{if(i.push(!0),a[l]=c,i.length===e.length)return s(a)}).catch(c=>n(c)))}return new Be(o)}}class Vo{constructor(){this.values=new Map,this.maxEntries=20}get(e){const i=this.values.has(e);let a;return i&&(a=this.values.get(e),this.values.delete(e),this.values.set(e,a)),a}put(e,i){if(this.values.size>=this.maxEntries){const a=this.values.keys().next().value;this.values.delete(a)}this.values.set(e,i)}}class ko{constructor(e,i,a){this.abortController=new AbortController,this.load(e,i,a),this.url=e.url}async load(e,i,a){try{const o=Vt[e.url],s=o.fetchOptions;s.signal=this.abortController.signal;const n=await fetch(e.url,s);let r;switch((s==null?void 0:s.output)||"arraybuffer"){case"json":r=await n.json();break;case"blob":r=await n.blob();break;case"text":r=await n.text();break;case"imageBitmap":{const l=await n.blob();r=await createImageBitmap(l,o);break}default:r=await n.arrayBuffer();break}i(r),delete Vt[e.url]}catch(o){a(o),delete Vt[e.url]}}cancel(){this.abortController.abort()}}const Vt={},ra=new ao(ko,50);class la{constructor(e={}){this.cache=new Vo,this.options=e}async load(e,i){e===void 0&&(e="");const a=this.cache.get(e);if(a!==void 0)return a;const o=ne({},this.options);return o.fetchOptions=ne(ne({},o.fetchOptions||{}),i||{}),Vt[e]=o,new Promise((s,n)=>{ra.add(e,function(r,l){l instanceof Error?n(l):s(l)},n)}).then(s=>(s&&this.cache.put(e,s),s))}cancel(e){ra.cancel(e)}}class Go extends la{constructor(e={}){super(ne({premultiplyAlpha:"none",colorSpaceConversion:"none"},e));this.options.fetchOptions=this.options.fetchOptions||{},this.options.fetchOptions.output||(this.options.fetchOptions.output="imageBitmap")}}let bi={},Ei={};function Ti(t){const e=JSON.stringify(t||{});return bi[e]||(bi[e]=new Go(t)),bi[e]}function Zo(t){const e=JSON.stringify(t||{});return Ei[e]||(Ei[e]=new la(t)),Ei[e]}class Di{constructor(){this.name="",this.minZoom=0,this.maxZoom=20,this.maxOverZoom=0,this.zoomDelta=0,this.minLevelForZoomDelta=0,this.bounds=[],this.center=[],this.fetchingTilesPromises=new Map}get actualMaxZoom(){return this.maxZoom+this.maxOverZoom}fetchImage(e,i,a){return null}getMetaData(){}async fetchTileImage(e,i,a){const o=`${e}_${i}_${a}`,s=this.fetchingTilesPromises[o]=this.fetchImage(e,i,a);this.fetchingTilesPromises[o]=s;try{return await s}finally{delete this.fetchingTilesPromises[o]}}cancelTile(e,i,a){const o=`${e}_${i}_${a}`,s=this.fetchingTilesPromises[o];s&&(s.cancel(),delete this.fetchingTilesPromises[o])}async fetchTile(e,i,a){return this.fetchTileImage(e,i,a)}}const Wo=Ti({imageOrientation:"flipY",fetchOptions:{credentials:"same-origin"}});function ca(t,e){if(t[0][2]===e)return t;if(t[0][2]<e){var i=[];return t.forEach(function(a){i=i.concat(le.getChildren(a))}),ca(i,e)}else{var t=t.map(function(o){const s=le.tileToBBOX(o);return le.pointToTile(s[0]+(s[2]-s[0])/2,s[1]+(s[3]-s[1])/2,e)});return t}}function jo(t,e){var i=ca(t,e);return i}class ha extends Di{constructor(e){super();this.address=e}getImageBitmapLoader(){return Wo}async fetchTileImage(e,i,a){const o=`${e}_${i}_${a}`;let s;if(this.zoomDelta<=0||this.minLevelForZoomDelta>e)s=this.fetchingTilesPromises[o]=this.fetchImage(e,i,a);else{const n=jo([[i,a,e]],e+this.zoomDelta).sort((l,c)=>c[1]-l[1]||l[0]-c[0]);let r;s=new Be((l,c)=>{Promise.all(r=n.map(h=>this.fetchImage(h[2],h[0],h[1]))).then(h=>{try{if(r=null,h=h.filter(L=>Boolean(L)),!h||!h.length)return l(null);const u=h[0].width*Math.floor(this.zoomDelta*2),w=u/Math.sqrt(h.length),x=bt.createOffscreenCanvas(u,u);var p=x.getContext("2d");let g=n[0][1],T=0,f=0,v,M;h.forEach((L,D)=>{g!==n[D][1]&&(g=n[D][1],T=0,f+=1),v=T*w,M=f*w,p.save(),p.drawImage(L,v,M,w,w),p.restore(),T+=1}),l(createImageBitmap(x))}catch(u){c(u)}}).catch(function(h){r=null,c(h)})},function(){return r&&(r.forEach(l=>l.cancel()),r=null),!0})}this.fetchingTilesPromises[o]=s;try{return await s}finally{delete this.fetchingTilesPromises[o]}}fetchImage(e,i,a){const o=this.buildURL(e,i,a);return new Be(async(s,n)=>{try{const r=await this.getImageBitmapLoader().load(o);s(r)}catch(r){console.log("catched error",r),n(r)}},()=>(this.getImageBitmapLoader().cancel(o),!0))}}class da extends ha{constructor(e="https://a.tile.openstreetmap.org/"){super(e);this.format="png"}buildURL(e,i,a){return this.address+e+"/"+i+"/"+a+"."+this.format}}class ua extends Mt{constructor(e,i,a,o,s,n,r){super();const l=n+r;let c=0;const h=[],p=new S,u=new S,w=[],x=[],g=[],T=[];for(let f=0;f<=a;f++){const v=[],M=f/a;for(let L=0;L<=i;L++){const D=L/i;p.x=-e*Math.cos(o+D*s)*Math.sin(n+M*r),p.y=e*Math.cos(n+M*r),p.z=e*Math.sin(o+D*s)*Math.sin(n+M*r),x.push(p.x,p.y,p.z),u.set(p.x,p.y,p.z).normalize(),g.push(u.x,u.y,u.z),T.push(D,1-M),v.push(c++)}h.push(v)}for(let f=0;f<a;f++)for(let v=0;v<i;v++){const M=h[f][v+1],L=h[f][v],D=h[f+1][v],he=h[f+1][v+1];(f!==0||n>0)&&w.push(M,L,he),(f!==a-1||l<Math.PI)&&w.push(L,D,he)}this.setIndex(w),this.setAttribute("position",new re(x,3)),this.setAttribute("normal",new re(g,3)),this.setAttribute("uv",new re(T,2))}}const Li=class extends P{constructor(t=null,e=null,i=P.root,a=0,o=0,s=0){super(t,e,i,a,o,s,Li.createGeometry(a,o,s),new vi({wireframe:!1}));this.applyScaleNode(),this.matrixAutoUpdate=!1}initialize(){return this.loadTexture()}static createGeometry(t,e,i){const a=Math.pow(2,t),o=40,s=Math.floor(Li.segments*(o/(t+1))/o),n=1/a*2*Math.PI,r=e*n,l=1/a*Math.PI,c=i*l;return new ua(1,s,s,r,n,c,l)}applyScaleNode(){this.geometry.computeBoundingBox();const e=this.geometry.boundingBox.clone().getCenter(new S),i=new Ht;i.compose(new S(-e.x,-e.y,-e.z),new Je,new S(N.EARTH_RADIUS,N.EARTH_RADIUS,N.EARTH_RADIUS)),this.geometry.applyMatrix4(i),this.position.copy(e),this.updateMatrix(),this.updateMatrixWorld()}updateMatrix(){this.matrix.setPosition(this.position),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t=!1){(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1)}createChildNodes(){const t=this.level+1,e=this.x*2,i=this.y*2,a=Object.getPrototypeOf(this).constructor;let o=new a(this,this.mapView,P.topLeft,t,e,i);this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0),o=new a(this,this.mapView,P.topRight,t,e+1,i),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0),o=new a(this,this.mapView,P.bottomLeft,t,e,i+1),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0),o=new a(this,this.mapView,P.bottomRight,t,e+1,i+1),this.add(o),o.updateMatrix(),o.updateMatrixWorld(!0)}raycast(t,e){return this.isVisible()?super.raycast(t,e):!1}};let kt=Li;kt.baseGeometry=new ua(N.EARTH_RADIUS,64,64,0,2*Math.PI,0,Math.PI);kt.baseScale=new S(1,1,1);kt.segments=80;const Fe=class extends ce{constructor(t=null,e=null,i=P.root,a=0,o=0,s=0){super(t,e,i,a,o,s,Fe.geometry,Fe.prepareMaterial(new wi({map:Fe.EMPTY_TEXTURE})));this.heightMapLocation=[0,0,1,1],this.overZoomFactor=1,this.frustumCulled=!1}static prepareMaterial(t){return t.userData={heightMap:{value:Fe.EMPTY_TEXTURE},elevationDecoder:{value:Fe.ELEVATION_DECODER},heightMapLocation:{value:new Bt}},t.onBeforeCompile=e=>{for(const i in t.userData)e.uniforms[i]=t.userData[i];e.vertexShader=`
			uniform sampler2D heightMap;
			uniform vec4 heightMapLocation;
			uniform vec4 elevationDecoder;
			float getPixelElevation(vec4 e) {
				// Convert encoded elevation value to meters
				return ((e.r * elevationDecoder.x + e.g * elevationDecoder.y  + e.b * elevationDecoder.z) + elevationDecoder.w) * exageration;
			}
			float getElevation(vec2 coord) {
				vec4 e = texture2D(heightMap, coord * heightMapLocation.zw + heightMapLocation.xy);
				return getPixelElevation(e);
			}
			`+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <fog_vertex>",`
			#include <fog_vertex>
	
			// Calculate height of the title
			float _height = getElevation(vUv);
			vec3 _transformed = position + _height * normal;
	
			// Vertex position based on height
			gl_Position = projectionMatrix * modelViewMatrix * vec4(_transformed, 1.0);
			`)},t}onHeightImage(t){if(t){const e=new ue(t);e.generateMipmaps=!1,e.format=Nt,e.magFilter=et,e.minFilter=et,e.needsUpdate=!0,this.material.userData.heightMap.value=e}}async handleParentOverZoomTile(t){const e=le.tileToBBOX([this.x,this.y,this.level]),i=this.parent,a=i.overZoomFactor,o=le.tileToBBOX([i.x,i.y,i.level]),s=o[2]-o[0],n=o[3]-o[1];this.overZoomFactor=a*2,this.heightMapLocation[0]=i.heightMapLocation[0]+Math.floor((e[0]-o[0])/s*10)/10/a,this.heightMapLocation[1]=i.heightMapLocation[1]+Math.floor((e[1]-o[1])/n*10)/10/a,this.heightMapLocation[2]=this.heightMapLocation[3]=1/this.overZoomFactor,this.material.userData.heightMapLocation.value.set(...this.heightMapLocation),await this.onHeightImage(i.material.userData.heightMap.value),t&&t()}raycast(t,e){if(this.isVisible()){this.geometry=Me.geometry;const i=super.raycast(t,e);return this.geometry=Fe.geometry,i}return!1}};let Ue=Fe;Ue.ELEVATION_DECODER=[6553.6*255,25.6*255,.1*255,-1e4];Ue.EMPTY_TEXTURE=new ue;Ue.geometrySize=256;Ue.geometry=new fe(1,1,ce.geometrySize,ce.geometrySize);Ue.baseGeometry=Me.geometry;Ue.baseScale=new S(N.EARTH_PERIMETER,1,N.EARTH_PERIMETER);class $o{constructor(){this.subdivisionRays=1,this.thresholdUp=.6,this.thresholdDown=.15,this.raycaster=new ta,this.mouse=new Ne,this.powerDistance=!1,this.scaleDistance=!0}updateLOD(e,i,a,o){const s=[];for(let n=0;n<this.subdivisionRays;n++)this.mouse.set(Math.random()*2-1,Math.random()*2-1),this.raycaster.setFromCamera(this.mouse,i),this.raycaster.intersectObjects(e.children,!0,s);for(let n=0;n<s.length;n++){const r=s[n].object;let l=s[n].distance;if(this.powerDistance&&(l=Math.pow(l*2,r.level)),this.scaleDistance){const c=r.matrixWorld.elements;l=new S(c[0],c[1],c[2]).length()/l}if(l>this.thresholdUp){r.subdivide();return}else if(l<this.thresholdDown&&r.parentNode!==null){r.parentNode.simplify();return}}}}class Xo{constructor(e=257){this.gridSize=e;const i=e-1;if(i&i-1)throw new Error(`Expected grid size to be 2^n+1, got ${e}.`);this.numTriangles=i*i*2-2,this.numParentTriangles=this.numTriangles-i*i,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(this.numTriangles*4);for(let a=0;a<this.numTriangles;a++){let o=a+2,s=0,n=0,r=0,l=0,c=0,h=0;for(o&1?r=l=c=i:s=n=h=i;(o>>=1)>1;){const u=s+r>>1,w=n+l>>1;o&1?(r=s,l=n,s=c,n=h):(s=r,n=l,r=c,l=h),c=u,h=w}const p=a*4;this.coords[p+0]=s,this.coords[p+1]=n,this.coords[p+2]=r,this.coords[p+3]=l}}createTile(e){return new qo(e,this)}}class qo{constructor(e,i){const a=i.gridSize;if(e.length!==a*a)throw new Error(`Expected terrain data of length ${a*a} (${a} x ${a}), got ${e.length}.`);this.terrain=e,this.martini=i,this.errors=new Float32Array(e.length),this.update()}update(){const{numTriangles:e,numParentTriangles:i,coords:a,gridSize:o}=this.martini,{terrain:s,errors:n}=this;for(let r=e-1;r>=0;r--){const l=r*4,c=a[l+0],h=a[l+1],p=a[l+2],u=a[l+3],w=c+p>>1,x=h+u>>1,g=w+x-h,T=x+c-w,f=(s[h*o+c]+s[u*o+p])/2,v=x*o+w,M=Math.abs(f-s[v]);if(n[v]=Math.max(n[v],M),r<i){const L=(h+T>>1)*o+(c+g>>1),D=(u+T>>1)*o+(p+g>>1);n[v]=Math.max(n[v],n[L],n[D])}}}getMesh(e=0,i=!1){const{gridSize:a,indices:o}=this.martini,{errors:s}=this;let n=0,r=0;const l=a-1;let c,h,p=0;const u=[],w=[],x=[],g=[];o.fill(0);function T(G,Z,z,I,W,$){const K=G+z>>1,ie=Z+I>>1;Math.abs(G-W)+Math.abs(Z-$)>1&&s[ie*a+K]>e?(T(W,$,G,Z,K,ie),T(z,I,W,$,K,ie)):(c=Z*a+G,h=I*a+z,p=$*a+W,o[c]===0&&(i&&(G===0?u.push(n):G===l&&w.push(n),Z===0?x.push(n):Z===l&&g.push(n)),o[c]=++n),o[h]===0&&(i&&(z===0?u.push(n):z===l&&w.push(n),I===0?x.push(n):I===l&&g.push(n)),o[h]=++n),o[p]===0&&(i&&(W===0?u.push(n):W===l&&w.push(n),$===0?x.push(n):$===l&&g.push(n)),o[p]=++n),r++)}T(0,0,l,l,l,0),T(l,l,0,0,0,l);let f=n*2,v=r*3;i&&(f+=(u.length+w.length+x.length+g.length)*2,v+=((u.length-1)*2+(w.length-1)*2+(x.length-1)*2+(g.length-1)*2)*3);const M=new Uint16Array(f),L=new Uint32Array(v);let D=0;function he(G,Z,z,I,W,$){const K=G+z>>1,ie=Z+I>>1;if(Math.abs(G-W)+Math.abs(Z-$)>1&&s[ie*a+K]>e)he(W,$,G,Z,K,ie),he(z,I,W,$,K,ie);else{const _e=o[Z*a+G]-1,dt=o[I*a+z]-1,ut=o[$*a+W]-1;M[2*_e]=G,M[2*_e+1]=Z,M[2*dt]=z,M[2*dt+1]=I,M[2*ut]=W,M[2*ut+1]=$,L[D++]=_e,L[D++]=dt,L[D++]=ut}}if(he(0,0,l,l,l,0),he(l,l,0,0,0,l),i){let G=function(z){const I=z.length;for(let W=0;W<I-1;W++){const $=z[W],K=z[W+1],ie=Z/2,_e=(Z+2)/2;M[Z++]=M[2*$],M[Z++]=M[2*$+1],L[D++]=$,L[D++]=ie,L[D++]=K,L[D++]=ie,L[D++]=_e,L[D++]=K}M[Z++]=M[2*z[I-1]],M[Z++]=M[2*z[I-1]+1]};u.sort((z,I)=>M[2*z+1]-M[2*I+1]),w.sort((z,I)=>M[2*I+1]-M[2*z+1]),x.sort((z,I)=>M[2*I]-M[2*z]),g.sort((z,I)=>M[2*z]-M[2*I]);let Z=n*2;G(u),G(w),G(x),G(g)}return{vertices:M,triangles:L,numVerticesWithoutSkirts:n}}}const Ve=class extends ce{constructor(t=null,e=null,i=P.root,a=0,o=0,s=0,{elevationDecoder:n=[256*255,255,1/256*255,-32768],meshMaxError:r=50,exageration:l=1}={}){super(t,e,i,a,o,s,Ve.geometry,Ve.prepareMaterial(new wi({map:Ve.emptyTexture,color:16777215,side:oo}),a,l));this.elevationDecoder=[256*255,255,1/256*255,-32768],this.exageration=1,this.meshMaxError=10,this.meshMaxError=t?t.meshMaxError:r,this.exageration=t?t.exageration:l,this.elevationDecoder=t?t.elevationDecoder:n,this.frustumCulled=!1}static prepareMaterial(t,e,i=1){return t.userData={heightMap:{value:Ve.emptyTexture},drawNormals:{value:0},drawBlack:{value:0},zoomlevel:{value:e},computeNormals:{value:1},drawTexture:{value:1}},t.onBeforeCompile=a=>{for(let o in t.userData)a.uniforms[o]=t.userData[o];a.vertexShader=`
				uniform bool computeNormals;
				uniform float zoomlevel;
				uniform sampler2D heightMap;
				`+a.vertexShader,a.fragmentShader=`
				uniform bool drawNormals;
				uniform bool drawTexture;
				uniform bool drawBlack;
				`+a.fragmentShader,a.fragmentShader=a.fragmentShader.replace("#include <dithering_fragment>",`
				if(drawBlack) {
					gl_FragColor = vec4( 0.0,0.0,0.0, 1.0 );
				} else if(drawNormals) {
					gl_FragColor = vec4( ( 0.5 * vNormal + 0.5 ), 1.0 );
				} else if (!drawTexture) {
					gl_FragColor = vec4( 0.0,0.0,0.0, 0.0 );
				}`),a.vertexShader=a.vertexShader.replace("#include <fog_vertex>",`
				#include <fog_vertex>

				// queried pixels:
				// +-----------+
				// |   |   |   |
				// | a | b | c |
				// |   |   |   |
				// +-----------+
				// |   |   |   |
				// | d | e | f |
				// |   |   |   |
				// +-----------+
				// |   |   |   |
				// | g | h | i |
				// |   |   |   |
				// +-----------+

					// if (computeNormals) {
					// 	float e = getElevation(vUv, 0.0);
					// 	ivec2 size = textureSize(heightMap, 0);
					// 	float offset = 1.0 / float(size.x);
					// 	float a = getElevation(vUv + vec2(-offset, -offset), 0.0);
					// 	float b = getElevation(vUv + vec2(0, -offset), 0.0);
					// 	float c = getElevation(vUv + vec2(offset, -offset), 0.0);
					// 	float d = getElevation(vUv + vec2(-offset, 0), 0.0);
					// 	float f = getElevation(vUv + vec2(offset, 0), 0.0);
					// 	float g = getElevation(vUv + vec2(-offset, offset), 0.0);
					// 	float h = getElevation(vUv + vec2(0, offset), 0.0);
					// 	float i = getElevation(vUv + vec2(offset,offset), 0.0);


					// 	float normalLength = 500.0 / zoomlevel;

					// 	vec3 v0 = vec3(0.0, 0.0, 0.0);
					// 	vec3 v1 = vec3(0.0, normalLength, 0.0);
					// 	vec3 v2 = vec3(normalLength, 0.0, 0.0);
					// 	v0.z = (e + d + g + h) / 4.0;
					// 	v1.z = (e+ b + a + d) / 4.0;
					// 	v2.z = (e+ h + i + f) / 4.0;
					// 	vNormal = (normalize(cross(v2 - v0, v1 - v0))).rbg;
					// }
				`)},t}static getTerrain(t,e,i){const a=e+1,o=new Float32Array(a*a);for(let s=0,n=0;n<e;n++)for(let r=0;r<e;r++,s++){const l=s*4,c=t[l+0],h=t[l+1],p=t[l+2];o[s+n]=c*i[0]/255+h*i[1]/255+p*i[2]/255+i[3]}for(let s=a*(a-1),n=0;n<a-1;n++,s++)o[s]=o[s-a];for(let s=a-1,n=0;n<a;n++,s+=a)o[s]=o[s-1];return o}static getMeshAttributes(t,e,i,a,o){const s=i+1,n=t.length/2,r=new Float32Array(n*3),l=new Float32Array(n*2),[c,h,p,u]=a||[0,0,i,i],w=(p-c)/i,x=(u-h)/i;for(let g=0;g<n;g++){const T=t[g*2],f=t[g*2+1],v=f*s+T;r[3*g+0]=T*w+c,r[3*g+1]=-e[v]*o,r[3*g+2]=-f*x+u,l[2*g+0]=T/i,l[2*g+1]=f/i}return{position:{value:r,size:3},uv:{value:l,size:2}}}async onHeightImage(t){if(t){const n=t.width,r=n+1;var e=bt.createOffscreenCanvas(n,n),i=e.getContext("2d");i.imageSmoothingEnabled=!1,i.drawImage(t,0,0,n,n,0,0,e.width,e.height);var a=i.getImageData(0,0,e.width,e.height),o=a.data;const l=Ve.getTerrain(o,n,this.elevationDecoder),h=new Xo(r).createTile(l),{vertices:p,triangles:u}=h.getMesh(typeof this.meshMaxError=="function"?this.meshMaxError(this.level):this.meshMaxError,!1),w=Ve.getMeshAttributes(p,l,n,[-.5,-.5,.5,.5],this.exageration);this.geometry=new Mt,this.geometry.setIndex(new so(u,1)),this.geometry.setAttribute("position",new re(w.position.value,w.position.size)),this.geometry.setAttribute("uv",new re(w.uv.value,w.uv.size)),this.geometry.rotateX(Math.PI);var s=new ue(t);s.generateMipmaps=!1,s.format=Nt,s.magFilter=et,s.minFilter=et,s.needsUpdate=!0,this.material.userData.heightMap.value=s}}loadHeightGeometry(){if(this.mapView.heightProvider===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");return this.mapView.heightProvider.fetchTile(this.level,this.x,this.y).then(async t=>this.onHeightImage(t)).finally(()=>{this.heightLoaded=!0,this.nodeReady()})}};let it=Ve;it.geometrySize=16;it.emptyTexture=new ue;it.geometry=new fe(1,1,1,1);it.tileSize=256;it.baseScale=new S(N.EARTH_PERIMETER,1,N.EARTH_PERIMETER);const ye=class extends zt{constructor(t=ye.PLANAR,e=new da,i=null,a=!1,o){super(void 0,new vi({transparent:!0,opacity:0}));this.lod=null,this.provider=null,this.heightProvider=null,this.root=null,this.onNodeReady=null,this.lowMemoryUsage=!1,this.maxZoomForPeaks=14,Bo(),this.lod=new $o,this.provider=e,this.heightProvider=i,this.nodeAutoLoad=a,o?this.onNodeReady=o:this.onBeforeRender=(s,n,r,l,c,h)=>{this.lod.updateLOD(this,r,s,n)},this.setRoot(t)}nodeShouldAutoLoad(){return this.nodeAutoLoad}setRoot(t){if(typeof t=="number"){if(!ye.mapModes.has(t))throw new Error("Map mode "+t+" does is not registered.");const e=ye.mapModes.get(t);t=new e(null,this)}this.root!==null&&(this.remove(this.root),this.root=null),this.root=t,this.root!==null&&(this.geometry=this.root.constructor.baseGeometry,this.scale.copy(this.root.constructor.baseScale),this.root.mapView=this,this.add(this.root))}setProvider(t){t!==this.provider&&(this.provider=t,this.clear())}setHeightProvider(t){t!==this.heightProvider&&(this.heightProvider=t,this.clear())}clear(){return this.traverseVisible(function(t){t.childrenCache&&(t.childrenCache=null),t.initialize&&t.initialize()}),this}getMetaData(){this.provider.getMetaData()}raycast(t,e){return!1}};let ke=ye;ke.PLANAR=200;ke.SPHERICAL=201;ke.HEIGHT=202;ke.HEIGHT_SHADER=203;ke.MARTINI=204;ke.mapModes=new Map([[ye.PLANAR,Me],[ye.SPHERICAL,kt],[ye.HEIGHT,ce],[ye.HEIGHT_SHADER,Ue],[ye.MARTINI,it]]);class Yo extends Di{constructor(){super(...arguments);this.resolution=256}fetchImage(e,i,a){return new Be((o,s)=>{const n=bt.createOffscreenCanvas(this.resolution,this.resolution),r=n.getContext("2d"),l=new yt(65280),c=new yt(16711680),h=l.lerpHSL(c,(e-this.minZoom)/(this.maxZoom-this.minZoom));r.fillStyle=h.getStyle(),r.fillRect(0,0,this.resolution,this.resolution),r.fillStyle="#000000",r.textAlign="center",r.textBaseline="middle",r.font="bold "+this.resolution*.1+"px arial",r.fillText("("+e+")",this.resolution/2,this.resolution*.4),r.fillText("("+i+", "+a+")",this.resolution/2,this.resolution*.6),o(n)})}}class Qo extends Di{constructor(){super();this.name="local",this.minZoom=0,this.maxZoom=20}fetchTile(e,i,a){return Promise.resolve(null)}cancelTile(e,i,a){}}const fa=Zo({fetchOptions:{credentials:"same-origin"}}),Ko=Ti({imageOrientation:"flipY",fetchOptions:{credentials:"same-origin"}});class Jo extends ha{constructor(e){super();this.name="local",this.local=e.local,this.localURL=e.localURL,console.log("LocalHeightProvider",e),this.minZoom=e.heightMinZoom||5,this.maxZoom=e.heightMaxZoom||15}buildURL(e,i,a){return this.local&&this.localURL?`${this.localURL}/data/elevation_25m/${e}/${i}/${a}.webp`:`https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${e}/${i}/${a}.png`}buildPeaksURL(e,i,a){return this.local&&this.localURL?`${this.localURL}/data/full/${e}/${i}/${a}.pbf`:`https://tiles.akylas.fr/data/v3/${e}/${i}/${a}.pbf`}getImageBitmapLoader(){return Ko}async fetchPeaks(e,i,a){const o=this.buildPeaksURL(e,i,a),s=await fa.load(o);return no.parse(s,{mvt:{tileIndex:{x:i,y:a,z:e},coordinates:"wgs84",layers:["mountain_peak"]}})}cancelTile(e,i,a){super.cancelTile(e,i,a);const o=this.buildPeaksURL(e,i,a);fa.cancel(o)}}const J=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),Ri=new Date,d={local:!1,localURL:"",terrarium:!0,heightMinZoom:5,heightMaxZoom:15,shadows:!0,dayNightCycle:!1,generateColor:!1,debug:!1,geometrySize:J?320:512,debugGPUPicking:!1,readFeatures:!0,drawLines:!0,drawElevations:!1,dark:!1,fovFactor:28.605121612548828,outline:!0,wireframe:!1,drawNormals:!1,debugFeaturePoints:!1,computeNormals:!1,drawTexture:!0,mapMap:!1,rasterProviderZoomDelta:2,maxZoomForPeaks:13,stats:!1,exageration:1.622511863708496,outlineStroke:1,depthBiais:.23,flipRasterImages:!0,depthMultiplier:11,depthPostMultiplier:.9277091026306152,secondsInDay:Ri.getHours()*3600+Ri.getMinutes()*60+Ri.getSeconds(),elevation:-1,stickToGround:!0,elevationDecoder:[6553.6*255,25.6*255,.1*255,-1e4],far:173e3,near:10};let ma={},Tt;function pa(t){Tt||(Tt=document.createElement("canvas")),Tt.width=t.width,Tt.height=t.height;var e=Tt.getContext("2d");return e.drawImage(t,0,0),e.getImageData(0,0,t.width,t.height)}let Dt,Gt,Zt;function ga(t,e,i,a){Dt=le.pointToTileFraction(i.lon,i.lat,a),Gt=Dt[0]-Math.floor(Dt[0]),Zt=1-(Dt[1]-Math.floor(Dt[1])),Gt=Gt*e[2]+e[0],Zt=Zt*e[3]+e[1];const o=Math.round(t.width*Gt),s=Math.round(t.height*Zt),n=(o+t.width*s)*4;return t.data.slice(n,n+4)}const Le=12,Ge=1/1e5;class va extends ia{onBeforeCompile(e){for(const i in this.userData)e.uniforms[i]=this.userData[i]}onBeforeRender(e,i,a,o,s,n){if(j.useSharedShader){const r=s.parent.parent;for(const l in r.userData)this.uniforms[l]=r.userData[l];this.uniformsNeedUpdate=!0}}}class es extends ia{onBeforeRender(e,i,a,o,s,n){for(const r in s.userData)this.uniforms[r]&&(this.uniforms[r].value=s.userData[r].value);this.uniformsNeedUpdate=!0}}const wa=new ue,at=new es({depthWrite:!1,depthTest:!1,extensions:{derivatives:!1},uniforms:{exageration:{value:1},depthTexture:{value:wa},cameraNear:{value:10*Ge},cameraFar:{value:1e6*Ge},worldScale:{value:Ge}},vertexShader:`
#include <packing>
attribute vec4 color;

uniform sampler2D depthTexture;
uniform float cameraNear;
uniform float cameraFar;
uniform float exageration;

varying vec2 vUv;
varying float depth;
varying vec4 vColor;

float readDepth(const in vec2 uv) {
return texture2D(depthTexture, uv).r;
}
float getViewZ(const in float depth) {
return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
}
float readZDepth(vec2 uv) {
return viewZToOrthographicDepth( getViewZ(readDepth(uv)), cameraNear, cameraFar );
}
void main() {
float elevation  = position.y;
vec4 mvPosition = modelViewMatrix * vec4( position.x,  elevation * exageration, position.z, 1.0 );
// mvPosition.z -= pow(getDigit(elevation, 2.0), 2.0) * mvPosition.z / 1000.0;
// mvPosition.z -= (elevation / 1000.0 - floor(elevation / 1000.0)) * mvPosition.z / 1000.0;
gl_Position = projectionMatrix * mvPosition;
gl_PointSize = 6.0;
float depthFromPosition = viewZToOrthographicDepth(mvPosition.z, cameraNear, cameraFar);
vec3 coord = gl_Position.xyz / gl_Position.w;
vUv =(coord.xy + 1.0) * 0.5 ;
// float depthAtPoint = readZDepth(vUv);
float depthAtPoint = (readZDepth(vUv) + readZDepth(vUv + vec2(0,0.001)) + readZDepth(vUv + vec2(0,-0.001)) + readZDepth(vUv + vec2(0.001,0)) + readZDepth(vUv + vec2(-0.001,0))) / 5.0;
if (depthAtPoint > 0.0 && depthFromPosition > depthAtPoint+ cameraFar/1000.0) {
	depth = -1.0;
	vColor = vec4( 0.0, 0.0, 0.0, 0.0);
} else {
	depth = depthAtPoint;
	vColor = color;
}
}
	`,fragmentShader:`
#include <packing>
varying vec4 vColor;
varying float depth;

void main() {
	if (depth < 0.0 ) {
		discard;
	}
	gl_FragColor = vColor;
}
	`,transparent:!1});function ts(t,...e){return e.reduce((i,a)=>(i[a]=t[a],i),{})}function is(){const t=ro.phong;new lo;let e,i,a,o,s,n;const r=new va({lights:!0,wireframe:!1,extensions:{derivatives:!0},defines:{TANGENTSPACE_NORMALMAP:"",USE_DISPLACEMENTMAP:"",USE_NORMALMAP:""},uniforms:Object.assign(ts(t.uniforms,"diffuse","spotLights","spotLightShadows","rectAreaLights","ltc_1","ltc_2","ambientLightColor","directionalLightShadows","directionalLights","directionalShadowMatrix","directionalShadowMap","lightMap","lightMapIntensity","lightProbe","pointLights","pointLightShadows","pointShadowMap","pointShadowMatrix","hemisphereLights","spotShadowMap","spotShadowMatrix","map","opacity","displacementMap"),{textureGrass:{value:e},textureAltitude:{value:i},textureRock:{value:a},textureSnow:{value:o},textureSand:{value:s},textureWater:{value:n},drawNormals:{value:!1},computeNormals:{value:!1},drawShadows:{value:!1},drawTexture:{value:!1},elevationDecoder:{value:null},generateColor:{value:!1},drawBlack:{value:0},displacementScale:{value:1},normalLength:{value:1},emissive:{value:new yt(0)},specular:{value:new yt(3355443)},shininess:{value:10},displacementBias:{value:0},worldScale:{value:Ge}}),vertexShader:`
#define PHONG
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <shadowmap_pars_vertex>
uniform bool computeNormals;
uniform bool drawShadows;
uniform float zoomlevel;
uniform float worldScale;
uniform float normalLength;
uniform float zoomFactor;
uniform vec4 elevationDecoder;
uniform vec4 displacementMapLocation;
uniform vec2 displacementRes;
varying vec4 vPosition;
uniform float tileY;
varying vec3 vViewPosition;
varying vec3 vComputedNormal;
varying float trueHeight;
uniform bool generateColor;

float getPixelElevation(vec4 e) {
	// Convert encoded elevation value to meters
	return ((e.r * elevationDecoder.x + e.g * elevationDecoder.y  + e.b * elevationDecoder.z) + elevationDecoder.w);
}
float getElevation(vec2 coord) {
	vec4 e = texture2D(displacementMap, coord * displacementMapLocation.zw + displacementMapLocation.xy);
	return getPixelElevation(e);
}

float getElevationMean(vec2 coord) {
	float x0 = coord.x;
	float x1= coord.x;
	float y0 = coord.y;
	float y1= coord.y;
	if (x0 <= 0.0) {
		x1 = 1.0 * displacementRes.x;
	}
	if (x0 >= 1.0) {
		x1 = 1.0 - 1.0  * displacementRes.x;
	}
	if (y0 <= 0.0) {
		y1 = 1.0 * displacementRes.y;
	}
	if (y0 >= 1.0) {
		y1 = 1.0 - 1.0 * displacementRes.y;
	}
	if (x0 == x1 && y0 == y1) {
		return getElevation(coord);
	} else {
		return 2.0 * getElevation(vec2(x0,y0)) -  getElevation(vec2(x1,y1));
	}
}
void main() {

	vUv = vec2(position.x +  0.5, 0.5 - position.z );

	float e = getElevationMean(vUv);
	vec3 transformedNormal = normalMatrix * vec3(0,1,0);
	vNormal = normalize( transformedNormal );
	vec3 transformed = vec3( position ) + vec3(0,e * displacementScale + displacementBias,0);
	#include <project_vertex>
	vViewPosition = - mvPosition.xyz;

	if (computeNormals) {

		vec3 offset = vec3(displacementRes, 0);
		float b = getElevation(vUv  - offset.zy);
		float d = getElevation(vUv - offset.xz);
		float f = getElevation(vUv + offset.xz);
		float h = getElevation(vUv + offset.zy);
		// float b = getElevationMean(vUv  - offset.zy);
		// float d = getElevationMean(vUv - offset.xz);
		// float f = getElevationMean(vUv + offset.xz);
		// float h = getElevationMean(vUv + offset.zy);
		vComputedNormal = normalize(vec3(mix(d - f , 0.0, zoomFactor), mix(b - h , 0.0, zoomFactor), normalLength));
	}
	#include <worldpos_vertex>
	if (drawShadows) {
		#include <shadowmap_vertex>
	}
	if (generateColor) {
		vPosition = modelMatrix * vec4(transformed, 1.0);
		vPosition.y = e;
	}
}
`,fragmentShader:`
#define PHONG
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <lightmap_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)
#include <normalmap_pars_fragment>
#define SNOW_HEIGHT 1300.0
#define BEACH_HEIGHT 10.5
#define GRASS_HEIGHT 2053.5
#define TREE_MIN_HEIGHT 1000.0
#define TREE_MAX_HEIGHT 1800.0
#define HASHSCALE1 .1031

uniform bool drawNormals;
uniform bool computeNormals;
uniform bool generateColor;
uniform bool drawTexture;
uniform bool drawBlack;
uniform vec4 mapMapLocation;
uniform float zoomlevel;
varying vec4 vPosition;
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float worldScale;
uniform float opacity;
uniform sampler2D textureGrass;
uniform sampler2D textureAltitude;
uniform sampler2D textureRock;
uniform sampler2D textureSnow;
uniform sampler2D textureSand;
uniform sampler2D textureWater;
varying vec3 vComputedNormal;

#include <shadowmap_pars_fragment>


vec2 add = vec2(1.0, 0.0);
//  1 out, 2 in...
float Hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}
float Noise( in vec2 x, float factor )
{
    vec2 p = floor(x*factor/worldScale);
    vec2 f = fract(x*factor/worldScale);
    f = f*f*(3.0-2.0*f);
    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),
                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);
    return res;
}
vec3 TerrainColour(vec4 matPos, vec3 normal, vec2 lights)
{
	float slope = normal.y;
	vec3 mat;
	// lights.x = .0;
	// lights.y = .1;
	// vec3 dir = normalize(pos-cameraPos);
	
	// float f = clamp(Noise(matPos.xz*.05, 2.0), 0.0,1.0);//*10.8;
	vec3 m = vec3(76.0/255.0, 51.0/255.0, 30.0/255.0);
	// vec3 m = texture2D(textureAltitude, vUv*2.0).rgb;
	mat = m;
	// Should have used smoothstep to add colours, but left it using 'if' for sanity...
	if (slope < .5)
	{
		float c = (.5-slope) * 4.0;
		c = clamp(c*c, 0.1, 1.0);
		mat = mix(mat, vec3(0.4, 0.4, 0.4), c/1.6);
		// mat = mix(mat, texture2D(textureRock, vUv*4.0).rgb, c/1.6);
		// lights.x+=.1;
	}
	// Grass. Use the normal to decide when to plonk grass down...
	if (matPos.y < GRASS_HEIGHT && slope > 0.65)
	{
		// m = texture2D(textureGrass, vUv*4.0).rgb*1.6 * (slope- 0.65);
		m = vec3(0.34902, 0.533333, 0.266667)*1.6 * (slope- 0.65);
		mat = mix(mat, m, clamp((slope-0.65)*1.3 * (GRASS_HEIGHT-matPos.y)*0.003, 0.0, 1.0));
	}

	// if (matPos.y > TREE_MIN_HEIGHT && matPos.y < TREE_MAX_HEIGHT && slope > .22)
	// {
	// 	mat = vec3(.02+Noise(matPos.xz*5.0, 1.0)*.03, .05, .0);
	// 	normal = normalize(normal+vec3(Noise(matPos.xz*33.0, 1.0)*1.0-.5, .0, Noise(matPos.xz*33.0, 1.0)*1.0-.5));
		// lights.x = .0;
	// }
	
	// Snow topped mountains...
	if (matPos.y > SNOW_HEIGHT && slope > .22)
	{
		float snow = clamp(((matPos.y - SNOW_HEIGHT)*(slope-0.22)*3.5) * 0.0015, 0.0, 1.0);
		mat = mix(mat, vec3(0.9,0.9,0.9), snow);
		// mat = mix(mat, texture2D(textureSnow, vUv).rgb, snow);
		// lights.x += snow;
		// ambient+=snow *.3;
	}
	// Beach effect...
	if (matPos.y < BEACH_HEIGHT)
	{
		if (slope > .4)
		{
			float sand = clamp((BEACH_HEIGHT-matPos.y) * 1.34, 0.0, 1.0);
			// float t = (slope-.4);
			// t = (t*t);
			// mat = mix(mat, texture2D(textureSand, vUv).rgb, sand);
			mat = mix(mat, vec3(0.929412, 0.929412, 0.8), sand);
		}
		// Cheap under water darkening...it's wet after all...
		// if (matPos.y <= 0.0)
		// {
		// 	mat *= .2;
		// }
	}
	// Do the water...
	if (matPos.y <= 1.0)
	{
		// mat = mix(mat, texture2D(textureWater, vUv).rgb, 0.8);
		// mat = texture2D(textureWater, vUv).rgb;
		mat = vec3(0.46, 0.812,0.941);
	}
	return mat;
}
void main() {
	

	vec3 normal = normalize( vNormal );
	if (computeNormals) {
		normal = perturbNormal2Arb( - vViewPosition, normal, vComputedNormal, 1.0 );
	}

	if(drawBlack) {
		gl_FragColor = vec4( 0.0,0.0,0.0, 1.0 );
		return;
	} else if(drawNormals) {
		gl_FragColor = vec4(packNormalToRGB(normal), opacity);
		return;
	} else if (!drawTexture) {
		gl_FragColor = vec4( 0.0,0.0,0.0, 0.0);
		return;
	}
	float specularStrength = 1.0;

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	if (generateColor) {
		vec2 lights = vec2(0,0);
		diffuseColor *= mapTexelToLinear(vec4(TerrainColour(vPosition, vComputedNormal.rbg, lights), 1.0));
		// specularStrength = lights.x;
	} else {
		vec4 texelColor = texture2D(map, vUv * mapMapLocation.zw + mapMapLocation.xy);
		// texelColor = mapTexelToLinear( texelColor );
		diffuseColor *= texelColor;
	}


	specularStrength =1.0;
	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_end>
	
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
}
`});return r.map=wa,r}const Pi=new va({defines:{USE_DISPLACEMENTMAP:""},name:"DepthMaterial",uniforms:{elevationDecoder:{value:null},displacementMapLocation:{value:new Bt},displacementScale:{value:1},displacementMap:{value:null},displacementBias:{value:0}},vertexShader:`
#include <displacementmap_pars_vertex>
uniform vec4 elevationDecoder;
uniform vec4 displacementMapLocation;

float getPixelElevation(vec4 e) {
	// Convert encoded elevation value to meters
	return ((e.r * elevationDecoder.x + e.g * elevationDecoder.y  + e.b * elevationDecoder.z) + elevationDecoder.w);
}
float getElevation(vec2 coord) {
	vec4 e = texture2D(displacementMap, coord * displacementMapLocation.zw + displacementMapLocation.xy);
	return getPixelElevation(e);
}
void main() {
	vec2 vUv = vec2(position.x +  0.5, 0.5 - position.z );
    vec3 pos = position + vec3(0,getElevation(vUv) * displacementScale  + displacementBias,0);
    gl_Position = projectionMatrix * viewMatrix *  modelMatrix * vec4(pos, 1.0);
}
`,fragmentShader:`
// #include <common>
#include <packing>
void main() {
	gl_FragColor = packDepthToRGBA( gl_FragCoord.z );
}`}),X=is();let xa=0;const _=class extends ce{constructor(t,e,i,a,o,s){super(t,e,i,a,o,s,_.getDefaultGeometry(),_.useSharedShader?X:X.clone());this.fullGeometryLoaded=!1,this.displacementMapLocation=[0,0,1,1],this.mapMapLocation=[0,0,1,1],this.heightOverZoomFactor=1,this.overZoomFactor=1;const n={displacementMap:{value:null},map:{value:this.material.map},zoomlevel:{value:a},tileY:{value:s},displacementMapLocation:{value:this.displacementMapLocation},displacementRes:{value:[0,0]},zoomFactor:{value:this.getZoomFactor()},mapMapLocation:{value:this.mapMapLocation}};_.useSharedShader?this.userData=n:this.material.userData=n,this.frustumCulled=!1}static getDefaultGeometry(){return _.geometry||(_.geometry=_.getSoftGeometry(16,!0)),_.geometry}static getGeometry(t){const e=Math.log(1/Ge)*Math.LOG10E+1|0;let i=d.geometrySize/Math.max(Math.floor(e/2),1);t>Le&&(i/=Math.floor(Math.pow(2,t-Le)),i=Math.max(16,i));let a=_.geometries[i];return _.geometries[i]||(a=_.geometries[i]=new fe(1,1,i,i,{skirt:d.exageration>.1,skirtDepth:50*d.exageration*_.scaleRatio,uvs:!1})),a}static getSoftGeometry(t,e){let i;if(e)i=t;else{const o=Math.log(1/Ge)*Math.LOG10E+1|0;i=d.geometrySize/Math.max(Math.pow(2,Math.floor(o/2)-1),1),t<Le?(i/=Math.floor(Math.pow(2,Math.floor(Le-t))),i=Math.max(16,i)):t>Le&&(i/=Math.floor(Math.pow(2,t-Le)),i=Math.max(16,i))}let a=_.geometries[i];return _.geometries[i]||(a=_.geometries[i]=new fe(1,1,i,i,{skirt:d.exageration>.1,skirtDepth:50*d.exageration,uvs:!1})),a}getZoomFactor(){let t=0,e=this.level;return this.displacementMapLocation[2]!==1&&(e-=Math.log(1/this.displacementMapLocation[2])/Math.log(2)),e<12&&(t=1-.5/(12-e)),t}initialize(){let t=2,e=this.parent;for(;t>0&&(!e.textureLoaded||!e.heightLoaded);)e=e.parent,t--;if(e&&e.textureLoaded&&e.heightLoaded){const i=le.tileToBBOX([this.x,this.y,this.level]),a=le.tileToBBOX([e.x,e.y,e.level]),o=a[2]-a[0],s=a[3]-a[1],n=this.level-e.level,r=Math.pow(10,n),l=Math.floor((i[0]-a[0])/o*r)/r,c=Math.floor((i[1]-a[1])/s*r)/r;if(!this.textureLoaded){const h=1/e.mapMapLocation[2],p=[0,0,1,1];p[0]=e.mapMapLocation[0]+l/h,p[1]=e.mapMapLocation[1]+c/h,p[2]=p[3]=1/Math.pow(2,h*n);const u=_.useSharedShader?e.userData:e.material.userData;this.setMaterialValues({map:u.map.value,mapMapLocation:p})}if(!this.heightLoaded){const h=e.displacementMapLocation,p=1/h[2],u=[0,0,1,1];u[0]=h[0]+l/p,u[1]=h[1]+c/p,u[2]=u[3]=1/(2*p*n);const w=_.useSharedShader?e.userData:e.material.userData;this.displacementMapLocation=u;const x=w.displacementMap.value;this.setMaterialValues({displacementMap:x,displacementMapLocation:u,displacementRes:[1/(x.image.width*u[2]),1/(x.image.height*u[3])],zoomFactor:this.getZoomFactor()})}this.show()}return super.initialize()}dispose(){super.dispose(),this.pointsMesh=null}setMaterialValues(t){const e=_.useSharedShader?this.userData:this.material.userData;Object.keys(t).forEach(i=>{e.hasOwnProperty(i)&&(e[i].value=t[i])})}didSimplify(){this.lod?this.children=[this.objectsHolder,this.lod]:this.children=[this.objectsHolder]}show(){this.fullGeometryLoaded||this.constructLOD(),_.useLOD?(this.isMesh=!1,this.lod.visible=!0):this.isMesh=!0}isVisible(){return _.useLOD?this.lod&&this.lod.visible:this.isMesh}hide(){this.isMesh=!1,this.objectsHolder.visible=this.level!==this.mapView.maxZoomForPeaks,this.lod&&(this.lod.visible=!1)}constructLOD(){if(this.fullGeometryLoaded=!0,_.useLOD){const t=this.lod=new co;for(let e=0;e<4;e++){let i=e>=3?e+1:e;const a=new zt(_.getSoftGeometry(this.level>Le?this.level+i:Le-i),this.material);a.frustumCulled=!1,a.castShadow=!0,a.receiveShadow=!0,a.customDepthMaterial=Pi,a.updateMatrix(),a.updateMatrixWorld(!0),a.matrixAutoUpdate=!1,t.addLevel(a,700*Math.pow(e,5))}t.updateMatrix(),t.updateMatrixWorld(!0),t.frustumCulled=!1,t.matrixAutoUpdate=!1,this.add(t),this.isMesh=!1}else this.geometry=_.getGeometry(this.level)}loadTexture(){if(!this.isTextureReady)return this.isTextureReady=!0,this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>this.onTextureImage(t)).finally(()=>{!this.mapView||(this.textureLoaded=!0,this.nodeReady())})}onTextureImage(t){if(this.parentNode&&t){this.mapMapLocation=[0,0,1,1];const e=new ue(t);e.generateMipmaps=!1,e.magFilter=Te,e.minFilter=Te,e.needsUpdate=!0,this.setMaterialValues({map:e,mapMapLocation:this.mapMapLocation})}}async onHeightImage(t,e=!0){if(this.mapView&&t){e&&(this.displacementMapLocation=[0,0,1,1]);let i;if(t instanceof ue?(i=t,this.setMaterialValues({displacementMap:t,displacementMapLocation:this.displacementMapLocation,displacementRes:[1/(i.image.width*this.displacementMapLocation[2]),1/(i.image.height*this.displacementMapLocation[3])]})):(i=new ue(t),i.generateMipmaps=!1,i.flipY=!1,i.wrapS=aa,i.wrapT=aa,i.magFilter=Te,i.minFilter=Te,i.needsUpdate=!0,this.setMaterialValues({displacementMap:i,displacementMapLocation:this.displacementMapLocation,displacementRes:[1/(i.image.width*this.displacementMapLocation[2]),1/(i.image.height*this.displacementMapLocation[3])],zoomFactor:this.getZoomFactor()})),this.level>this.mapView.maxZoomForPeaks)return;await this.mapView.heightProvider.fetchPeaks(this.level,this.x,this.y).then(a=>{if(!!this.mapView&&(a=a.filter(r=>r.properties.name&&r.properties.class==="peak"&&r.properties.ele!==void 0),a.length>0)){const r=d.elevationDecoder,l=[];var o=[],s=[];const c=new S(0,0,0),p=(_.useSharedShader?this.userData:this.material.userData).displacementMapLocation.value;let u,w=new Ne,x,g;const T=pa(i.image),f=_.scaleRatio;if(a.forEach((v,M)=>{if(u=v.geometry.coordinates,N.datumsToSpherical(u[1],u[0],w,f),c.set(w.x,0,-w.y),v.localCoords=this.worldToLocal(c),Math.abs(v.localCoords.x)<=.5&&Math.abs(v.localCoords.z)<=.5){const L=u.join(",");v.id=L,v.pointIndex=l.length,v.level=this.level,v.x=this.x,v.y=this.y,x=ga(T,p,{lat:u[1],lon:u[0]},this.level);const D=v.properties.computedEle=Math.ceil(x[0]/255*r[0]+x[1]/255*r[1]+x[2]/255*r[2]+r[3]);v.localCoords.y=D,g=v.color=xa=(xa+1)%16777214,ma[g]=v,l.push(v),o.push((g>>16&255)/255,(g>>8&255)/255,(g&255)/255),s.push(v.localCoords.x,v.localCoords.y,v.localCoords.z)}}),s.length>0){const v=new Mt,M=new re(s,3);M.name="points",v.setAttribute("position",M);const L=new re(o,3);L.name="colors",v.setAttribute("color",L);var n=new ho(v,at);n.userData={},n.frustumCulled=!1,n.updateMatrix(),n.updateMatrixWorld(!0),this.pointsMesh=n,this.objectsHolder.add(n)}}}).catch(a=>{console.error("error fetching peaks",a)})}}async handleParentOverZoomTile(t){if(!this.mapView)return;const e=le.tileToBBOX([this.x,this.y,this.level]),i=this.parent,a=i.heightOverZoomFactor,o=le.tileToBBOX([i.x,i.y,i.level]),s=o[2]-o[0],n=o[3]-o[1];this.heightOverZoomFactor=a*2,this.displacementMapLocation[0]=i.displacementMapLocation[0]+Math.floor((e[0]-o[0])/s*10)/10/a,this.displacementMapLocation[1]=i.displacementMapLocation[1]+Math.floor((e[1]-o[1])/n*10)/10/a,this.displacementMapLocation[2]=this.displacementMapLocation[3]=1/this.heightOverZoomFactor;const r=_.useSharedShader?i.userData:i.material.userData;await this.onHeightImage(r.displacementMap.value,!1),t==null||t()}raycast(t,e){if(this.isVisible()){const i=this.geometry;this.geometry=Me.geometry;const a=zt.prototype.raycast.call(this,t,e);return this.geometry=i,a}return!1}};let j=_;j.useLOD=!0;j.useSharedShader=!0;j.baseGeometry=Me.geometry;j.scaleRatio=Ge;j.baseScale=new S(N.EARTH_PERIMETER*_.scaleRatio,Number(_.scaleRatio),N.EARTH_PERIMETER*_.scaleRatio);j.geometries={};j.geometrySize=4;j.maxZoomForPeaks=12;class as extends da{constructor(e={}){super(e.local&&e.localURL?e.localURL+`/styles/${e.style||"basic"}/`:"https://a.tile.openstreetmap.org/");this.imageBitmapLoader=Ti({imageOrientation:e.flipRasterImages?"flipY":void 0,fetchOptions:{credentials:"same-origin"}})}getImageBitmapLoader(){return this.imageBitmapLoader}}class os extends uo{constructor(e,i,a,o,s=1){super(16777215);this.savedPosition=new S(0,0,0),this.coordinates=new Ne,this.coordinates.copy(e),this.north=i,this.east=a,this.nadir=o,this.sun_distance=s,this.azimuth=0,this.elevation=0,this.localDate=new Date,this.castShadow=!0}setWorldPosition(e){this.savedPosition.set(e.x,e.y,e.z),this.updateDirectionalLight()}setPosition(e,i){this.coordinates.set(e,i),this.updateOrientation(!1),this.updateDirectionalLight()}setDate(e){this.localDate=e,this.updateOrientation(!1),this.updateDirectionalLight()}updateOrientation(e=!0){e&&(this.localDate=new Date);const a=new ss().getAzEl(this.coordinates.x,this.coordinates.y,this.localDate);this.azimuth=this._degreesToRadians(a.azimuth),this.elevation=this._degreesToRadians(a.elevation)}updateDirectionalLight(){const e=-2,i=180*this.elevation/Math.PI;if(i<e){this.intensity=0;return}else i<0&&i>=e?this.intensity=i/e:this.intensity=2;this.position.copy(this.north),this.position.multiplyScalar(this.sun_distance);const a=new Je,o=new Je;a.setFromAxisAngle(this.east,this.elevation),o.premultiply(a),a.setFromAxisAngle(this.nadir,this.azimuth),o.premultiply(a),this.position.applyQuaternion(o),this.position.add(this.savedPosition),this.target.position.copy(this.savedPosition)}_degreesToRadians(e){return e%360*Math.PI/180}}class ss{constructor(){this.a="some val"}getAzEl(e,i,a=new Date){const o=this._getJD(a),s=this._getTimeLocal(a),n=a.getTimezoneOffset()/-60,r=o+s/1440-n/24,l=this._calcTimeJulianCent(r);return this._calcAzEl(!1,l,s,e,i,n)}_getJD(e=new Date){let i=e.getMonth()+1,a=e.getDate(),o=e.getFullYear();this._isLeapYear(o)&&i===2?a>29&&(a=29):a>new Date(1900,i,0).getDate()&&(a=new Date(1900,i,0).getDate()),i<=2&&(o-=1,i+=12);const s=Math.floor(o/100),n=2-s+Math.floor(s/4);return Math.floor(365.25*(o+4716))+Math.floor(30.6001*(i+1))+a+n-1524.5}_getTimeLocal(e=new Date){let i=0;return i+=60*e.getHours(),i+=e.getMinutes(),i+=e.getSeconds()/60,i}_calcTimeJulianCent(e){return(e-2451545)/36525}_calcAzEl(e,i,a,o,s,n){const r={azimuth:0,elevation:0},l=this._calcEquationOfTime(i),c=this._calcSunDeclination(i),h=l+4*s-60*n;this._calcSunRadVector(i);let p=a+h;for(;p>1440;)p-=1440;let u=p/4-180;u<-180&&(u+=360);const w=this._degToRad(u);let x=Math.sin(this._degToRad(o))*Math.sin(this._degToRad(c))+Math.cos(this._degToRad(o))*Math.cos(this._degToRad(c))*Math.cos(w);x>1?x=1:x<-1&&(x=-1);const g=this._radToDeg(Math.acos(x)),T=Math.cos(this._degToRad(o))*Math.sin(this._degToRad(g));if(Math.abs(T)>.001){let D=(Math.sin(this._degToRad(o))*Math.cos(this._degToRad(g))-Math.sin(this._degToRad(c)))/T;Math.abs(D)>1&&(D<0?D=-1:D=1);var f=180-this._radToDeg(Math.acos(D));u>0&&(f=-f)}else o>0?f=180:f=0;f<0&&(f+=360);const v=90-g;if(v>85)var M=0;else{const D=Math.tan(this._degToRad(v));if(v>5)var M=58.1/D-.07/(D*D*D)+86e-6/(D*D*D*D*D);else if(v>-.575)var M=1735+v*(-518.2+v*(103.4+v*(-12.79+v*.711)));else var M=-20.774/D;M=M/3600}const L=g-M;return r.azimuth=Math.floor(f*100+.5)/100,r.elevation=Math.floor((90-L)*100+.5)/100,r}_isLeapYear(e){return e%4==0&&e%100!=0||e%400==0}_radToDeg(e){return 180*e/Math.PI}_degToRad(e){return Math.PI*e/180}_calcEquationOfTime(e){const i=this._calcObliquityCorrection(e),a=this._calcGeomMeanLongSun(e),o=this._calcEccentricityEarthOrbit(e),s=this._calcGeomMeanAnomalySun(e);let n=Math.tan(this._degToRad(i)/2);n*=n;const r=Math.sin(2*this._degToRad(a)),l=Math.sin(this._degToRad(s)),c=Math.cos(2*this._degToRad(a)),h=Math.sin(4*this._degToRad(a)),p=Math.sin(2*this._degToRad(s)),u=n*r-2*o*l+4*o*n*l*c-.5*n*n*h-1.25*o*o*p;return this._radToDeg(u)*4}_calcSunDeclination(e){const i=this._calcObliquityCorrection(e),a=this._calcSunApparentLong(e),o=Math.sin(this._degToRad(i))*Math.sin(this._degToRad(a));return this._radToDeg(Math.asin(o))}_calcSunRadVector(e){const i=this._calcSunTrueAnomaly(e),a=this._calcEccentricityEarthOrbit(e);return 1.000001018*(1-a*a)/(1+a*Math.cos(this._degToRad(i)))}_calcObliquityCorrection(e){const i=this._calcMeanObliquityOfEcliptic(e),a=125.04-1934.136*e;return i+.00256*Math.cos(this._degToRad(a))}_calcSunApparentLong(e){const i=this._calcSunTrueLong(e),a=125.04-1934.136*e;return i-.00569-.00478*Math.sin(this._degToRad(a))}_calcGeomMeanLongSun(e){let i=280.46646+e*(36000.76983+e*3032e-7);for(;i>360;)i-=360;for(;i<0;)i+=360;return i}_calcEccentricityEarthOrbit(e){return .016708634-e*(42037e-9+1267e-10*e)}_calcGeomMeanAnomalySun(e){return 357.52911+e*(35999.05029-1537e-7*e)}_calcSunTrueAnomaly(e){const i=this._calcGeomMeanAnomalySun(e),a=this._calcSunEqOfCenter(e);return i+a}_calcMeanObliquityOfEcliptic(e){const i=21.448-e*(46.815+e*(59e-5-e*.001813));return 23+(26+i/60)/60}_calcSunTrueLong(e){const i=this._calcGeomMeanLongSun(e),a=this._calcSunEqOfCenter(e);return i+a}_calcSunEqOfCenter(e){const i=this._calcGeomMeanAnomalySun(e),a=this._degToRad(i),o=Math.sin(a),s=Math.sin(a+a),n=Math.sin(a+a+a);return o*(1.914602-e*(.004817+14e-6*e))+s*(.019993-101e-6*e)+n*289e-6}}const we=Math.PI/180,Si=180/Math.PI,ns=new URLSearchParams(window.location.search);ns.forEach((t,e)=>{try{d[e]=JSON.parse(t)}catch{d[e]=t}});function Ma(){q.shadowMap.enabled=X.uniforms.drawShadows.value=d.shadows&&d.dayNightCycle}let rs;function ot(t,e,i=!0,a=!0){try{if(!d.hasOwnProperty(t)){const n=window[t];typeof n=="function"&&n(e,i,a)}const o=d[t];if(t==="elevation"&&(typeof e=="string"&&(e=parseFloat(e)),Ze!==void 0&&e<Ze&&(e=Ze)),$t&&o===e)return;d[t]=e;let s=e;switch(t){case"terrarium":e?d.elevationDecoder=[256*255,1*255,1/256*255,-32768]:d.elevationDecoder=[6553.6*255,25.6*255,.1*255,-1e4],X.uniforms.elevationDecoder.value=d.elevationDecoder,Pi.uniforms.elevationDecoder.value=d.elevationDecoder;break;case"dayNightCycle":{if(!Y){Y=ds(),H=new os(new Ne(45.05,5.47),new S(0,0,-1),new S(1,0,0),new S(0,-1,0),2),H.shadow.bias=-2e-4,H.shadow.mapSize.width=8192,H.shadow.mapSize.height=8192,H.shadow.camera.left=-1,H.shadow.camera.right=1,H.shadow.camera.top=.1,H.shadow.camera.bottom=-.5,H.shadow.camera.near=.1,H.shadow.camera.far=5,xe.add(Y),xe.add(H),xe.add(H.target),E.getPosition(B),H.setWorldPosition(B);let n=new Date;const r=Math.floor(d.secondsInDay/3600),l=Math.floor((d.secondsInDay-r*3600)/60),c=d.secondsInDay-r*3600-l*60;n.setHours(r),n.setMinutes(l),n.setSeconds(c),H.setDate(n)}Yt(),Ui(),X.uniforms.computeNormals.value=lt(),Ma();break}case"shadows":{Ma();break}case"drawTexture":{X.uniforms.drawTexture.value=_i();break}case"elevation":{E.getPosition(B);const n=j.scaleRatio;E.moveTo(B.x,e*d.exageration*n,B.z),i&&(Ce(),i=!1);break}case"secondsInDay":{let n=new Date;const r=Math.floor(e/3600),l=Math.floor((e-r*3600)/60),c=e-r*3600-l*60;n.setHours(r),n.setMinutes(l),n.setSeconds(c),H&&(H.setDate(n),St()),s=n.toLocaleString(),Ui();break}case"dark":{document.body.style.backgroundColor=d.dark?"black":"white",ki.uniforms.get("outlineColor").value.set(d.dark?16777215:0);break}case"outline":{$e.enabled=!ji(),si.renderToScreen=!$e.enabled;break}case"near":{U.near=d.near*Se;break}case"far":{const n=j.scaleRatio;U.far=d.far*n,U.updateProjectionMatrix(),ai(),at.uniforms.cameraNear.value=U.near,at.uniforms.cameraFar.value=U.far;break}case"readFeatures":{Re.style.visibility=d.readFeatures?"visible":"hidden";break}case"exageration":{X.uniforms.displacementScale.value=d.exageration,X.uniforms.normalLength.value=30/d.exageration,Pi.uniforms.displacementScale.value=d.exageration,at.uniforms.exageration.value=d.exageration;break}case"depthBiais":case"outlineStroke":case"depthMultiplier":case"depthPostMultiplier":{ki.uniforms.get("multiplierParameters").value.set(d.depthBiais,d.depthMultiplier,d.depthPostMultiplier,d.outlineStroke);break}case"wireframe":{X.wireframe=d.wireframe;break}case"debugGPUPicking":{e&&!Pe?(Pe=Po(q,qt),document.body.append(Pe)):!e&&Pe&&(document.body.removeChild(Pe),Pe=null);break}case"debugFeaturePoints":{C&&ni(n=>{n.objectsHolder.visible=d.debugFeaturePoints&&(n.isVisible()||n.level===C.maxZoomForPeaks&&n.parentNode.subdivided)});break}case"computeNormals":{Yt(),X.uniforms.computeNormals.value=lt();break}case"stats":{e?(be||(be=new Ro,be.showPanel(0)),document.body.appendChild(be.dom)):be&&document.body.removeChild(be.dom);break}case"drawNormals":{X.uniforms.computeNormals.value=lt(),X.uniforms.drawNormals.value=d.drawNormals,X.uniforms.drawTexture.value=_i();break}case"rasterProviderZoomDelta":case"mapMap":{$e.enabled=!ji(),si.renderToScreen=!$e.enabled,Yt(),St(),X.uniforms.computeNormals.value=lt(),X.uniforms.drawTexture.value=_i(),C&&(C.provider=Ni(),e&&Sa("map"),i&&zi());break}case"maxZoomForPeaks":case"local":case"localURL":case"flipRasterImages":case"heightMinZoom":case"heightMaxZoom":case"geometrySize":{C&&Hi();break}case"generateColor":{X.uniforms.computeNormals.value=lt(),X.uniforms.generateColor.value=d.generateColor,X.uniforms.drawTexture.value=(d.debug||d.mapMap||d.generateColor)&&d.drawTexture,St();break}case"fovFactor":{U.fov=Jt=Fi(),U.updateProjectionMatrix();break}case"debug":{$e.enabled=!ji(),si.renderToScreen=!$e.enabled,Yt(),X.uniforms.computeNormals.value=lt(),X.uniforms.drawTexture.value=(d.debug||d.mapMap||d.generateColor)&&d.drawTexture,C&&(C.provider=Ni(),e&&Sa("debug"),i&&zi());break}}Lt[t]?Lt[t].checked=e:Rt[t]&&(Rt[t].value=e),Ii[t]&&(Ii[t].innerText=s),i&&Ae()}catch(o){console.error(o.toString()+" "+o.stack)}}class ls extends Ft{constructor(){super(...arguments);this.screenOrientation=0,this.deviceOrientation={},this.deviceOrientationEnabled=!1,this.orientationAzimuth=0,this.orientationPolar=0,this.alphaOffsetAngle=0,this.betaOffsetAngle=0,this.gammaOffsetAngle=0,this.zee=new S(0,0,1),this.euler=new So,this.q0=new Je,this.q1=new Je,this.wordVec=new S,this.trucking=!1,this.zooming=!1,this.ignoreUpdateDispatch=!1}updateDeviceOrientationQuaternion(){var e=this.deviceOrientation.alpha?this.deviceOrientation.alpha*we+this.alphaOffsetAngle:0,i=this.deviceOrientation.beta?this.deviceOrientation.beta*we+this.betaOffsetAngle:0,a=this.deviceOrientation.gamma?this.deviceOrientation.gamma*we+this.gammaOffsetAngle:0,o=this.screenOrientation?this.screenOrientation*we:0;this.setObjectQuaternion(this._camera.quaternion,e,i,a,o),this._camera.getWorldDirection(this.wordVec),this.orientationAzimuth=Math.atan2(this.wordVec.x,this.wordVec.z)+Math.PI,this.orientationPolar=Math.atan2(this.wordVec.z,this.wordVec.y)+Math.PI}onDeviceOrientationChangeEvent(e){this.deviceOrientation=e,this.updateDeviceOrientationQuaternion(),this.dispatchEvent({type:"update",originalEvent:e})}onCompassNeedsCalibrationEvent(){console.log("onCompassNeedsCalibrationEvent")}onScreenOrientationChangeEvent(e){this.screenOrientation=window.orientation||0,this.dispatchEvent({type:"control",originalEvent:e})}startDeviceOrientation(){this.deviceOrientationEnabled||(this.deviceOrientationEnabled=!0,this.screenOrientation=window.orientation||0,this.onDeviceOrientationChangeEventBound=this.onDeviceOrientationChangeEvent.bind(this),this.onScreenOrientationChangeEventBound=this.onScreenOrientationChangeEvent.bind(this),this.onCompassNeedsCalibrationEventBound=this.onCompassNeedsCalibrationEvent.bind(this),window.addEventListener("orientationchange",this.onScreenOrientationChangeEventBound,!1),"ondeviceorientationabsolute"in window?window.addEventListener("deviceorientationabsolute",this.onDeviceOrientationChangeEventBound,!1):window.addEventListener("deviceorientation",this.onDeviceOrientationChangeEventBound,!1),window.addEventListener("compassneedscalibration",this.onCompassNeedsCalibrationEventBound,!1))}stopDeviceOrientation(){!this.deviceOrientationEnabled||(this.deviceOrientationEnabled=!1,this.rotateTo(this.orientationAzimuth,this.orientationPolar),window.removeEventListener("orientationchange",this.onScreenOrientationChangeEventBound,!1),"ondeviceorientationabsolute"in window?window.removeEventListener("deviceorientationabsolute",this.onDeviceOrientationChangeEventBound,!1):window.removeEventListener("deviceorientation",this.onDeviceOrientationChangeEventBound,!1),window.addEventListener("compassneedscalibration",this.onCompassNeedsCalibrationEventBound,!1))}setObjectQuaternion(e,i,a,o,s){this.q0.identity(),this.q1.set(-Math.sqrt(.5),0,0,Math.sqrt(.5)),this.euler.set(a,i,-o,"YXZ"),e.setFromEuler(this.euler),e.multiply(this.q1),e.multiply(this.q0.setFromAxisAngle(this.zee,-s))}rotate(e,i,a){if(this.deviceOrientationEnabled)this.updateAlphaOffsetAngle(this.alphaOffsetAngle+e),this.updateBetaOffsetAngle(this.betaOffsetAngle+i);else return super.rotate(e,i,a)}truck(e,i,a){return this.trucking=!0,super.truck(e,i,a)}zoom(e,i){return this.zooming=!0,super.zoom(e,i)}zoomTo(e,i){return this.zooming=!0,super.zoomTo(e,i)}dispatchEvent(e){this.ignoreUpdateDispatch&&e.type==="update"||(super.dispatchEvent(e),e.type==="update"&&(this.trucking=!1,this.zooming=!1))}update(e){return this.deviceOrientationEnabled?(this.ignoreUpdateDispatch=!0,super.update(e),this.updateDeviceOrientationQuaternion(),this.ignoreUpdateDispatch=!1,this.dispatchEvent({type:"update",originalEvent:null}),!0):super.update(e)}updateAlphaOffsetAngle(e){this.alphaOffsetAngle=e}updateBetaOffsetAngle(e){this.betaOffsetAngle=e}updateGammaOffsetAngle(e){this.gammaOffsetAngle=e}dispose(){this.stopDeviceOrientation(),super.dispose()}}class cs extends Co{constructor(){super("CustomOutlineEffect",`
uniform vec3 weights;
uniform vec3 outlineColor;
uniform vec4 multiplierParameters;

float readZDepth(vec2 uv) {
	return viewZToOrthographicDepth( getViewZ(readDepth(uv)), cameraNear, cameraFar );
}
void mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {
	float zdepth = viewZToOrthographicDepth( getViewZ(depth), cameraNear, cameraFar );
	vec3 offset = vec3( texelSize * multiplierParameters.w, 0.0 );
	float depthDiff = abs(zdepth - readZDepth(uv + offset.xz))
					+ abs(zdepth - readZDepth(uv - offset.xz))
					+ abs(zdepth - readZDepth(uv + offset.zy))
					+ abs(zdepth - readZDepth(uv - offset.zy));
	depthDiff = depthDiff * multiplierParameters.y;
	depthDiff = pow(depthDiff, multiplierParameters.x);
	// depthDiff = depthDiff * multiplierParameters.z;
	vec4 outlineColor = vec4(outlineColor, depthDiff);
	outputColor = vec4(mix(inputColor, outlineColor, depthDiff));
}
`,{attributes:Oo.DEPTH,blendFunction:Ao.AVERAGE,uniforms:new Map([["outlineColor",new oa(new yt(d.dark?16777215:0))],["multiplierParameters",new oa(new Bt(d.depthBiais,d.depthMultiplier,d.depthPostMultiplier,d.outlineStroke))]])})}}Ft.install({THREE:{MOUSE:fo,Vector2:Ne,Vector3:S,Vector4:Bt,Quaternion:Je,Matrix4:Ht,Spherical:mo,Box3:po,Sphere:go,Raycaster:ta,MathUtils:{DEG2RAD:tt.DEG2RAD,clamp:tt.clamp}}});function ya(t,e){var i=!1;return function(){i||(t.apply(this,arguments),i=!0,setTimeout(function(){i=!1},e))}}function hs(t,e){var i=null;return function(){i&&(clearTimeout(i),i=null),i=setTimeout(function(...a){t.apply(this,...a),i=null},e)}}const Wt=window.devicePixelRatio;let ba=[];const B=new S(0,0,0);let Ea=-1,V,Ci=!1,Ze;const Ta=new vo;let F=null,C;const Da=1e-5;let me;const st=J?170:120;let pe=null,nt=!1,Q=window.innerWidth,ee=window.innerHeight,We=window.innerWidth,je=window.innerHeight,La=1,Oi=!1,jt=!1,Ai=!1,$t=!0,be;const Xt=document.getElementById("canvas"),Re=document.getElementById("canvas4");document.getElementById("video");const O=Re.getContext("2d");Xt.addEventListener("touchstart",()=>Ta.getDelta(),{passive:!0});const q=new wo({canvas:Xt,antialias:!1,alpha:!0,powerPreference:"high-performance",stencil:!1});q.physicallyCorrectLights=!0;q.shadowMap.type=xo;q.shadowMap.enabled=!1;q.setClearColor(0,0);const qt=new Mo(100,100,{generateMipmaps:!1,stencilBuffer:!1,depthBuffer:!1,minFilter:et,magFilter:et});let Pe;const rt=new yo(q,{});function lt(){return d.computeNormals||d.drawNormals||d.generateColor||(d.debug||d.mapMap||d.shadows)&&d.dayNightCycle}function _i(){return(d.debug||d.mapMap||d.generateColor)&&d.drawTexture}function Ra(){return d.dayNightCycle}function ds(){if(Y)return;Y=new _o,Y.scale.setScalar(1e8);const t={turbidity:0,rayleigh:.5,mieCoefficient:.005,mieDirectionalG:.7,inclination:.48,azimuth:.25,exposure:q.toneMappingExposure},e=Y.material.uniforms;e.turbidity.value=t.turbidity,e.rayleigh.value=t.rayleigh,e.mieCoefficient.value=t.mieCoefficient,e.mieDirectionalG.value=t.mieDirectionalG;const i=Math.PI*(t.inclination-.5),a=2*Math.PI*(t.azimuth-.5),o=new S;return o.x=Math.cos(a),o.y=Math.sin(a)*Math.sin(i),o.z=Math.sin(a)*Math.cos(i),e.sunPosition.value.copy(o),Y}const xe=new bo;let Pa;function Sa(t){const e=Pa!==t;Pa=t,ni(i=>{const a=j.useSharedShader?i.userData:i.material.userData;i.isVisible()&&(e||!(a.map&&a.map.value))&&(a.map.value=null,i.isTextureReady=!1,i.initialize())})}function Yt(){St(),!!Y&&(H.visible=Ra(),Y.visible=Ra())}let Lt={},Ii={},Rt={},Qt,Ca;const us=document.getElementById("compass"),Oa=document.getElementById("compass_slice"),Aa=document.getElementById("compass_label"),_a=document.getElementById("camera_button");_a&&(_a.style.visibility=J?"visible":"hidden");Object.keys(d).forEach(t=>{let e=document.getElementById(t+"Label");e&&(Ii[t]=e);const i=document.getElementById(t);!i||(i.type==="checkbox"?(Lt[t]=i,Lt[t].onchange=a=>ot(t,a.target.checked),Lt[t].checked=d[t]):i.type==="range"&&(Rt[t]=i,Rt[t].oninput=a=>ot(t,a.target.value),Rt[t].value=d[t]))}),Qt=document.getElementById("selectedPeakLabel"),Ca=document.getElementById("selectedPeak");const fs=new Eo(Xt);fs.on("tap",function(t){pe=new Ne(t.center.x,t.center.y),Ae(!0)});let ct;const Kt=hs(function(t=!1){!Ai||!C||!V||C.lod.updateLOD(C,U,q,xe,t)},J?200:0);function Ia(){if(us){let t;E.deviceOrientationEnabled?t=E.orientationAzimuth*Si%360:t=E.azimuthAngle*Si%360,Aa&&(Aa.innerText=t.toFixed()+"\xB0");const e=Jt*Q/ee;Oa.style.backgroundImage=`conic-gradient(transparent 0deg,transparent ${180-e/2}deg, #15BFCC ${180-e/2}deg, #15BFCC ${180+e/2}deg, transparent ${180+e/2}deg)`,Oa.style.transform=`rotateZ(${-t-180}deg)`}}function zi(t=!1){E.getPosition(B),Kt(t),Ia(),Ae()}function ms(){const t=j.scaleRatio;ct.maxOverZoom=J?0:2,J?(Pt.subdivideDistance=60*t,Pt.simplifyDistance=160*t):(Pt.subdivideDistance=70*t,Pt.simplifyDistance=170*t)}const Pt=new Uo;function Ni(){let t;return d.mapMap?(t=new as(d),t.zoomDelta=d.rasterProviderZoomDelta):d.debug?t=new Yo:t=new Qo,t.minZoom=5,t.maxZoom=ct.maxZoom+ct.maxOverZoom,t.minLevelForZoomDelta=11,t}function ps(t){if(Ae(),V&&Ci&&t.level>ct.maxZoom-3){const e=le.tileToBBOX([t.x,t.y,t.level]);V.lat>=e[1]&&V.lat<=e[3]&&V.lon>=e[0]&&V.lon<=e[2]&&za(V,t)}}function Hi(){if(C!==void 0&&(xe.remove(C),Et(C.root),C=void 0),!$t)return;ct=new Jo(d),ms();const t=Ni();C=new ke(null,t,ct,!1,ps),C.lowMemoryUsage=!0,C.maxZoomForPeaks=d.maxZoomForPeaks,C.setRoot(new j(null,C,P.root,0,0,0)),C.lod=Pt,C.updateMatrixWorld(!0),xe.add(C)}let Bi=(screen.orientation||{}).type;function Fi(){if(J){const t=Q>ee?ee/Q:Q/ee;return(/landscape/.test(Bi)?t:1)*d.fovFactor}return d.fovFactor}let Jt=Fi();const Se=j.scaleRatio,U=new To(Jt,Q/ee,d.near*Se,d.far*Se);window.addEventListener("orientationchange",function(t){Bi=t.target.screen.orientation.type,U.fov=Jt=Fi(),U.updateProjectionMatrix(),E.azimuthRotateSpeed=E.polarRotateSpeed=ei()/oi,Ia()},!1);U.position.set(0,0,Da);const E=new ls(U,Xt);function Ce(){E.update(1)}function ei(){if(J){const t=Q>ee?ee/Q:Q/ee;return(/landscape/.test(Bi)?t:1)*-.12}else return-.1}E.azimuthRotateSpeed=ei();E.polarRotateSpeed=ei();E.minZoom=1;E.maxZoom=20;E.truckSpeed=1/Da*1e5*Se;E.mouseButtons.wheel=Ft.ACTION.ZOOM;E.touches.two=Ft.ACTION.TOUCH_ZOOM_TRUCK;E.verticalDragToForward=!0;E.saveState();let ti=5,ii=.05;if(!J){const t={W:87,A:65,S:83,D:68,Q:81,E:69,ARROW_LEFT:37,ARROW_UP:38,ARROW_RIGHT:39,ARROW_DOWN:40},e=new ge(t.W,16.666),i=new ge(t.A,16.666),a=new ge(t.S,16.666),o=new ge(t.D,16.666);new ge(t.Q,16.666),new ge(t.E,16.666),i.addEventListener("holding",function(c){E.truck(-ti*Se*c.deltaTime,0,!1),E.update(c.deltaTime)}),o.addEventListener("holding",function(c){E.truck(ti*Se*c.deltaTime,0,!1),E.update(c.deltaTime)}),e.addEventListener("holding",function(c){E.forward(ti*Se*c.deltaTime,!1),E.update(c.deltaTime)}),a.addEventListener("holding",function(c){E.forward(-ti*Se*c.deltaTime,!1),E.update(c.deltaTime)});const s=new ge(t.ARROW_LEFT,16.666),n=new ge(t.ARROW_RIGHT,16.666),r=new ge(t.ARROW_UP,16.666),l=new ge(t.ARROW_DOWN,16.666);s.addEventListener("holding",function(c){E.rotate(ii*tt.DEG2RAD*c.deltaTime,0,!0),E.update(c.deltaTime)}),n.addEventListener("holding",function(c){E.rotate(-ii*tt.DEG2RAD*c.deltaTime,0,!0),E.update(c.deltaTime)}),r.addEventListener("holding",function(c){E.rotate(0,-ii*tt.DEG2RAD*c.deltaTime,!0),E.update(c.deltaTime)}),l.addEventListener("holding",function(c){E.rotate(0,ii*tt.DEG2RAD*c.deltaTime,!0),E.update(c.deltaTime)})}let H,Y;const Oe=new Do(16777215);Oe.castShadow=!1;xe.add(Oe);function St(){(d.mapMap||d.debug)&&d.dayNightCycle?Oe.intensity=1:d.generateColor?Oe.intensity=d.dayNightCycle?2:3:Oe.intensity=3}function Ui(){if(!Y)return;const t=Math.PI/2-H.elevation,e=Math.PI-H.azimuth,i=new S;i.setFromSphericalCoords(1,t,e),Y.material.uniforms.sunPosition.value.copy(i)}function ai(){zs()}function gs(t,e=!1,i=!0){if(t===V)return;E.getPosition(B);const a=j.scaleRatio,o=N.sphericalToDatums(B.x/a,-B.z/a);Ct(null);const s=N.datumsToSpherical(t.lat,t.lon,null,a);if(e){const n=li(o,t),r=d.elevation;let l=r;t.altitude&&(Ea=t.altitude+100,l=Ea);const c=n>1e5?11e3*d.exageration:l;ka({from:{x:B.x,y:-B.z,progress:0},to:Ke(ne({},s),{progress:1}),duration:Math.min(n/20,3e3),preventComputeFeatures:!0,onUpdate:h=>{const w=h,{progress:p}=w,u=ea(w,["progress"]);if(p<=.5){const x=2*p;E.moveTo(u.x,(r+x*(c-r))*d.exageration*a,-u.y,!1)}else{const x=(p-.5)*2;E.moveTo(u.x,(c+x*(l-c))*d.exageration*a,-u.y,!1)}Ce()},onEnd:()=>{V=t,ot("elevation",l,!1),ai(),Vi()}})}else t.altitude&&ot("elevation",t.altitude,!1),E.moveTo(s.x,d.elevation*d.exageration*a,-s.y,!1),ai(),i&&Ce(),Y&&(H.setPosition(t.lat,t.lon),E.getPosition(B),H.setWorldPosition(B),St(),Ui())}window.setPosition=gs;function za(t=V,e,i=60){if(Ci=!1,t){const a=vs(t,e);if(a===-1e5||isNaN(a))Ci=!0;else{const o=Ze||a,s=d.elevation-o;Ze=a,s>0&&s<500&&ot("elevation",Ze+Math.max(s,i))}}else Ze=void 0}function vs(t,e){const i=C.heightProvider.maxZoom;let a=i,o;for(;!e&&a>i-3;)o=le.pointToTileFraction(t.lon,t.lat,a),e=Ho(o[2],Math.floor(o[0]),Math.floor(o[1])),a-=1;if(e&&e.heightLoaded&&e.userData.displacementMap.value){const s=e.userData.displacementMap.value,n=e.userData.displacementMapLocation.value,r=ga(pa(s.image),n,t,e.level),l=d.elevationDecoder;return r[0]/255*l[0]+r[1]/255*l[1]+r[2]/255*l[2]+l[3]}else return-1e5}let Vi;function ws(t){Vi=ya(function(){Ke(ne({},V),{altitude:d.elevation})},t)}ws(100);function xs(){E.getPosition(B);const t=j.scaleRatio,e=N.sphericalToDatums(B.x/t,-B.z/t);(!V||V.lat!==e.lat||V.lon!==e.lon)&&(H&&H.setWorldPosition(B),V=e,d.stickToGround&&za(),Vi())}E.addEventListener("update",()=>{nt||xs(),zi()});E.addEventListener("controlend",()=>{Kt(),E.getPosition(B);const t=j.scaleRatio,e=N.sphericalToDatums(B.x/t,-B.z/t);(!V||V.lat!==e.lat||V.lon!==e.lon||V.altitude!==d.elevation)&&(V=Ke(ne({},e),{altitude:d.elevation}),ai()),Ae(!0)});let oi=U.zoom;E.addEventListener("control",t=>{E.zooming;const e=E.trucking;oi!==U.zoom&&(oi=U.zoom,E.azimuthRotateSpeed=E.polarRotateSpeed=ei()/oi),Ce(),F&&e&&Rs()});function Ms(t,e){window.nsWebViewBridge&&window.nsWebViewBridge.emit(t,typeof e=="function"?e():e)}class ys extends Io{constructor(e,i){super(e,i)}render(e,i,a,o,s){C.visible=!1,super.render(e,i,a,o,s),C.visible=!0}}const si=new Lo(xe,U);rt.addPass(si);const ki=new cs,$e=new ys(U,ki);rt.addPass($e);let Na=0;function Ha(){let t,e,i=Oe.visible;Oe.visible=!1,Y&&(t=Y.visible,e=H.visible,Y.visible=!1,H.visible=!1),at.uniforms.depthTexture.value=rt.depthTexture,ni(a=>{const o=a.isVisible();o&&(a.wasVisible=o,a.hide()),a.objectsHolder.visible=o||a.level===C.maxZoomForPeaks&&a.parentNode.subdivided}),d.debugFeaturePoints&&q.render(xe,U),q.setRenderTarget(qt),q.clear(),q.render(xe,U),q.setRenderTarget(null),Cs(),at.uniforms.depthTexture.value=null,ni(a=>{a.wasVisible&&(delete a.wasVisible,a.show()),a.objectsHolder.visible=a.isVisible()&&d.debugFeaturePoints||a.level===C.maxZoomForPeaks&&a.parentNode.subdivided}),Y&&(Y.visible=t,H.visible=e),Oe.visible=i}const bs=ya(Ha,J?300:100);document.body.onresize=function(){Ai=!0,Q=window.innerWidth,ee=window.innerHeight;const t=Q/ee;t>1?(We=800,je=Math.round(We/t)):(je=800,We=Math.round(je*t)),Na=st/ee*je,Re.width=Math.floor(Q*Wt),Re.height=Math.floor(ee*Wt),La=1+(Wt-1)/2,q.setSize(Q,ee),q.setPixelRatio(La),me=new Uint8Array(We*je*4),qt.setSize(We,je),rt.setSize(Q,ee),U.aspect=t,U.updateProjectionMatrix(),!C&&V&&Hi(),Kt(),Ae(!0)};document.body.onresize();Ce();function Es(t){const e=t.clone();e.project(U);const i=Q/2,a=ee/2;return e.x=e.x*i+i,e.y=-(e.y*a)+a,e.z=U.position.distanceTo(t),e}function Gi(t,e){e(t),t.children.forEach(i=>{i instanceof P&&Gi(i,e)}),t.childrenCache&&t.childrenCache.forEach(i=>{i instanceof P&&Gi(i,e)})}function ni(t){C&&Gi(C.children[0],t)}function Ba(t,e,i,a,o,s,n=!1){const r=e.split(" ");let l="",c=1;for(let h=0;h<r.length;h++){const p=l+(h>0?" ":"")+r[h];t.measureText(p).width>o&&h>0?(n||t.fillText(l,i,a),l=r[h],a+=s,c++):l=p}if(n||t.fillText(l,i,a),n)return{x:i+t.measureText(l).width,y:a,nbLines:c}}function Ts(t,e,i,a,o,s){a<2*s&&(s=a/2),o<2*s&&(s=o/2),t.beginPath(),t.moveTo(e+s,i),t.arcTo(e+a,i,e+a,i+o,s),t.arcTo(e+a,i+o,e,i+o,s),t.arcTo(e,i+o,e,i,s),t.arcTo(e,i,e+a,i,s),t.closePath()}function Ds(t,e){return t.length>e?t.slice(0,e-1)+"\u2026":t}function Ls(){const t={lat:F.geometry.coordinates[1],lon:F.geometry.coordinates[0],altitude:F.properties.ele},e=li(V,t);Qt.innerText=F.properties.name+" "+F.properties.ele+"m("+Math.round(e/100)/10+"km)"}function Rs(){Ms("selected",()=>{let t=0;if(F){E.getPosition(B);const e=j.scaleRatio,i=N.sphericalToDatums(B.x/e,-B.z/e),a={lat:F.geometry.coordinates[1],lon:F.geometry.coordinates[0],altitude:F.properties.ele};return t=li(i,a),Ke(ne({},F),{distance:t})}return null})}function Ct(t){pe=null,t!==F&&(F=t,Qt&&(F?Ls():Qt.innerText=null,Ca.style.visibility=F?"visible":"hidden"))}function Ot(t){return d.local?F&&t.properties.osmid===F.properties.osmid:F&&t.properties.name===F.properties.name&&t.properties.ele===F.properties.ele}function Zi(t){return Math.sqrt(Math.pow(pe.x-t.x,2)+Math.pow(pe.y-t.y,2))}const ht=J?26:36;function Ps(){if(!d.readFeatures||nt)return;const t=new Array(Q);let e=-1e4,i;const a=[],o=j.scaleRatio;ba.forEach(r=>{const l=N.datumsToSpherical(r.geometry.coordinates[1],r.geometry.coordinates[0],null,o),c=r.properties.ele||0;B.set(l.x,c*d.exageration*o,-l.y);const h=Es(B),p=Math.floor(h.x),u=h.y,w=h.z;if(u<st-20)return;c>e&&(i=p,e=c),(t[p]=t[p]||[]).push(Ke(ne({},r),{x:p,y:u,z:w}))});let s=i;function n(r,l,c){const h=t.slice(r,l).filter(u=>Boolean(u)).flat();if(h.length===0)return s+=c,!0;let p;if(pe&&pe.x>=r&&pe.x<=l){const u=h.reduce((w,x)=>!Ot(w)&&(Zi(w)<Zi(x)||Ot(x))?w:x);Zi(u)<20&&(p=u,Ct(p))}if(!p&&F){const u=h.findIndex(w=>Ot(w));u!==-1&&(p=h[u])}p||(p=h.reduce((u,w)=>Math.pow(u.properties.ele,2)>Math.pow(w.properties.ele,2)?u:w)),s=p.x+c,a.push(p)}for(s=i-ht/2;s<Q;)!n(s,s+ht,ht);for(s=i-ht;s>=0;)!n(s-ht,s,-ht);Wi(a)}const At=15,Fa=-Math.PI/4,Ss=Math.round(st/Math.cos(Fa)-20),Ua=-16,Va=21,ri=!J;function Wi(t){const e=Wt,i=t.length;O.save(),O.clearRect(0,0,Re.width,Re.height),O.scale(e,e);const a=d.dark?"white":"black",o=d.dark?"#000000":"#ffffff";let s,n,r,l,c,h,p,u,w,x;for(let g=0;g<i;g++){s=t[g],n=s.y,r=F&&Ot(s),d.drawLines&&n>st&&(O.beginPath(),O.strokeStyle=a,O.lineWidth=r?3:1,O.moveTo(s.x,st),O.lineTo(s.x,n),O.closePath(),O.stroke()),O.save(),O.translate(s.x,st),O.rotate(Fa),r?O.font=`bold ${At}px Noto Sans`:O.font=`${At}px Noto Sans`,l=ri?s.properties.name:Ds(s.properties.name,30),c=O.measureText(l).width,h=Math.min(c,Ss);let T={y:ri&&d.drawElevations?At:0,x:ri?0:h};ri&&c!==h&&(T=Ba(O,l,5,0,h,At,!0));let f=h+10,v;if(d.drawElevations&&(v=s.properties.ele+"m",p=O.measureText(v).width,f+=p-5),pe&&(u=O.getTransform().inverse(),w=new DOMPoint(pe.x*e,pe.y*e),x=w.matrixTransform(u),x.x>=0&&x.x<f&&x.y<-Ua&&x.y>=-(Va+T.y))){let M=F!==s;if(Ct(s),M)return O.restore(),O.restore(),Wi(t)}O.fillStyle=o+"cc",Ts(O,0,Ua,f,Va+T.y,8),O.fill(),O.fillStyle=a,T.y!==0?Ba(O,l,5,0,h,At):O.fillText(l,5,0),d.drawElevations&&(O.font="normal 11px Courier",O.fillText(v,T.x+10,T.y)),O.restore()}O.restore(),pe&&F&&(Ct(null),Wi(t))}function Cs(){const t=We;q.readRenderTargetPixels(qt,0,0,We,je,me);const e=[],i=[];let a=Boolean(F),o;function s(r){const l=e.indexOf(o);if(l===-1){const c=ma[o];if(c){e.push(o);const h=ne({},c);return i.push(h),a&&Ot(c)&&(a=!1),h}}else return i[l]}const n=me.length-Na*4*t;for(let r=0;r<n;r+=4)if(me[r+3]!==0&&(me[r]!==0||me[r+1]!==0||me[r+2]!==0)){const l=(me[r]<<16)+(me[r+1]<<8)+me[r+2];o!==l&&(o&&s(),o=l)}else o&&(s(),o=null);o&&(s(),o=null),a&&Ct(null),ba=i}function ji(){return(d.debug||d.mapMap||d.generateColor)&&!d.outline}function Os(t){rt.render(Ta.getDelta()),!nt&&d.readFeatures&&me&&(t?Ha():bs()),Ps()}function Ae(t=!1){!Ai||(!jt&&t&&(jt=t),Oi||(Oi=!0,requestAnimationFrame(As)))}function As(){Oi=!1,!(!q||!rt||!C)&&(Os(jt),jt=!1,Pe&&Pe.update(),be&&be.update())}document.addEventListener("DOMContentLoaded",function(){const t=Object.assign({},d,{setPosition:{lat:45.1811,lon:5.8141,altitude:2144},setAzimuth:0});Is(t)});function ka({from:t,to:e,duration:i,onUpdate:a,onEnd:o,preventComputeFeatures:s}){nt=s,nt&&O.clearRect(0,0,Re.width,Re.height),new zo({onRender:a,onFinish:()=>{o&&o(),nt=!1,Ae(!0)}}).tween(t,e,i)}function _s(t,e=!0,i=!0){const a=E.azimuthAngle*Si%360;a!==t&&(Math.abs(t-360-a)<Math.abs(t-a)&&(t=t-360),e?ka({from:{progress:a},to:{progress:t},duration:200,onUpdate:function(o){E.azimuthAngle=o.progress*we,Ce()}}):(E.azimuthAngle=t*we,i&&Ce()))}window.setAzimuth=_s;function Is(t){try{$t=!1,Object.keys(t).sort().forEach(e=>{const i=t[e];ot(e,i,!1,!1)}),$t=!0,C||(Hi(),Kt()),Ae(!0),Ce()}catch(e){console.error(e)}}function li(t,e){const i=(t.latitude||t.lat)*we,a=(t.longitude||t.lon)*we,o=(e.latitude||e.lat)*we,s=(e.longitude||e.lon)*we;return Math.round(Math.acos(Math.sin(o)*Math.sin(i)+Math.cos(o)*Math.cos(i)*Math.cos(a-s))*N.EARTH_RADIUS)}function zs(){if(!V)return 0;var t=new S(0,0,-U.far);t.applyMatrix4(U.matrixWorld);const e=j.scaleRatio,i=N.sphericalToDatums(t.x/e,-t.z/e);return li(V,i)}
