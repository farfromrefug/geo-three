<!DOCTYPE html>
<html>
    <head>
        <title></title>
    </head>
    <body>
        <!-- GUI -->
        <canvas
            id="canvas"
            style="
                position: absolute;
                top: 0px;
                left: 0px;
                width: 100%;
                height: 100%;
            "
        ></canvas>
        <select
            id="mode"
            style="
                position: absolute;
                top: 20px;
                right: 20px;
                width: 200px;
                height: 25px;
            "
        ></select>
        <select
            id="providerColor"
            style="
                position: absolute;
                top: 50px;
                right: 20px;
                width: 200px;
                height: 25px;
            "
        ></select>
        <select
            id="providerHeight"
            style="
                position: absolute;
                top: 80px;
                right: 20px;
                width: 200px;
                height: 25px;
            "
        ></select>
        <select
            id="lod"
            style="
                position: absolute;
                top: 110px;
                right: 20px;
                width: 200px;
                height: 25px;
            "
        ></select>

        <!-- Code -->
        <script
            type="text/javascript"
            src="../node_modules/three/build/three.min.js"
        ></script>
        <script
            type="text/javascript"
            src="../node_modules/three/examples/js/controls/OrbitControls.js"
        ></script>
        <script
            type="text/javascript"
            src="../node_modules/three/examples/js/controls/FirstPersonControls.js"
        ></script>
        <script
            type="text/javascript"
            src="../node_modules/three/examples/js/postprocessing/EffectComposer.js"
        ></script>
        <script
            type="text/javascript"
            src="../node_modules/three/examples/js/postprocessing/RenderPass.js"
        ></script>
        <script
            type="text/javascript"
            src="../node_modules/three/examples/js/postprocessing/ShaderPass.js"
        ></script>
        <script
            type="text/javascript"
            src="../node_modules/three/examples/js/shaders/CopyShader.js"
        ></script>
        <script
            type="text/javascript"
            src="../node_modules/three/examples/js/objects/Sky.js"
        ></script>
        <script type="text/javascript" src="../build/geo-three.js"></script>
        <script type="text/javascript">
            // Follows the structure of
            // 		https://github.com/mrdoob/three.js/blob/master/examples/jsm/postprocessing/OutlinePass.js
            class CustomOutlinePass extends THREE.Pass {
                constructor(resolution, scene, camera) {
                    super();

                    this.renderScene = scene;
                    this.renderCamera = camera;
                    this.resolution = new THREE.Vector2(
                        resolution.x,
                        resolution.y
                    );

                    this.fsQuad = new THREE.Pass.FullScreenQuad(null);
                    this.fsQuad.material = this.createOutlinePostProcessMaterial();

                    // Create a buffer to store the normals of the scene onto
                    const normalTarget = new THREE.WebGLRenderTarget(
                        this.resolution.x,
                        this.resolution.y
                    );
                    normalTarget.texture.format = THREE.RGBFormat;
                    normalTarget.texture.minFilter = THREE.NearestFilter;
                    normalTarget.texture.magFilter = THREE.NearestFilter;
                    normalTarget.texture.generateMipmaps = false;
                    normalTarget.stencilBuffer = false;
                    this.normalTarget = normalTarget;

                    this.normalOverrideMaterial = new THREE.MeshNormalMaterial();
                }

                dispose() {
                    this.normalTarget.dispose();
                    this.fsQuad.dispose();
                }

                setSize(width, height) {
                    this.normalTarget.setSize(width, height);
                    this.resolution.set(width, height);

                    const size = Math.max(width, height);
                    // console.log('setSize', width, height);
                    this.fsQuad.material.uniforms.screenSize.value.set(
                        2000,
                        2000,
                        1 / 2000,
                        1 / 2000
                    );
                }

                render(renderer, writeBuffer, readBuffer) {
                    // Turn off writing to the depth buffer
                    // because we need to read from it in the subsequent passes.
                    const depthBufferValue = writeBuffer.depthBuffer;
                    writeBuffer.depthBuffer = false;

                    // 1. Re-render the scene to capture all normals in texture.
                    // Ideally we could capture this in the first render pass along with
                    // the depth texture.
                    map.traverse(function (children) {
                        if (
                            children.material &&
                            children.material.userData &&
                            children.material.userData.drawNormals
                        ) {
                            children.material.userData.drawNormals.value = true;
                        }
                    });
                    renderer.setRenderTarget(this.normalTarget);

                    // const overrideMaterialValue = this.renderScene
                    // .overrideMaterial;
                    // this.renderScene.overrideMaterial = this.normalOverrideMaterial;
                    renderer.render(this.renderScene, this.renderCamera);
                    // this.renderScene.overrideMaterial = overrideMaterialValue;
                    map.traverse(function (children) {
                        if (
                            children.material &&
                            children.material.userData &&
                            children.material.userData.drawNormals
                        ) {
                            children.material.userData.drawNormals.value = false;
                        }
                    });

                    this.fsQuad.material.uniforms["depthBuffer"].value =
                        readBuffer.depthTexture;
                    this.fsQuad.material.uniforms[
                        "normalBuffer"
                    ].value = this.normalTarget.texture;
                    this.fsQuad.material.uniforms["sceneColorBuffer"].value =
                        readBuffer.texture;

                    // 2. Draw the outlines using the depth texture and normal texture
                    // and combine it with the scene color
                    if (this.renderToScreen) {
                        // If this is the last effect, then renderToScreen is true.
                        // So we should render to the screen by setting target null
                        // Otherwise, just render into the writeBuffer that the next effect will use as its read buffer.
                        renderer.setRenderTarget(null);
                        this.fsQuad.render(renderer);
                    } else {
                        renderer.setRenderTarget(writeBuffer);
                        this.fsQuad.render(renderer);
                    }

                    // Reset the depthBuffer value so we continue writing to it in the next render.
                    writeBuffer.depthBuffer = depthBufferValue;
                }

                get vertexShader() {
                    return `
            	varying vec2 vUv;
            	void main() {
            		vUv = uv;
            		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            	}
            	`;
                }
                get fragmentShader() {
                    return `
            	#include <packing>
            	// The above include imports "perspectiveDepthToViewZ"
            	// and other GLSL functions from ThreeJS we need for reading depth.
            	uniform sampler2D sceneColorBuffer;
            	uniform sampler2D depthBuffer;
            	uniform sampler2D normalBuffer;
            	uniform float cameraNear;
            	uniform float cameraFar;
            	uniform vec4 screenSize;
            	uniform vec3 outlineColor;
            	uniform vec4 multiplierParameters;
            	varying vec2 vUv;
            	// Helper functions for reading from depth buffer.
            	float readDepth (sampler2D depthSampler, vec2 coord) {
            		float fragCoordZ = texture2D(depthSampler, coord).x;
            		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
            		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
            	}
            	float getLinearDepth(vec3 pos) {
            		return -(viewMatrix * vec4(pos, 1.0)).z;
            	}
            	float getLinearScreenDepth(sampler2D map) {
            			vec2 uv = gl_FragCoord.xy * screenSize.zw;
            			return readDepth(map,uv);
            	}
            	// Helper functions for reading normals and depth of neighboring pixels.
            	float getPixelDepth(float x, float y) {
            		// screenSize.zw is pixel size
            		// vUv is current position
            		return readDepth(depthBuffer, vUv + screenSize.zw * vec2(x, y));
            	}
            	vec3 getPixelNormal(int x, int y) {
            		return texture2D(normalBuffer, vUv + screenSize.zw * vec2(x, y)).rgb;
            	}
            	float saturate(float num) {
            		return clamp(num, 0.0, 1.0);
            	}
            	void main() {
            		vec4 sceneColor = vec4(1.0,1.0,1.0,1.0);
            		float depth = getPixelDepth(0.0, 0.0);
            		vec3 normal = getPixelNormal(0, 0);
            		// Get the difference between depth of neighboring pixels and current.
            		float depthDiff = 0.0;
            		depthDiff += abs(depth - getPixelDepth(1.0, 0.0));
            		depthDiff += abs(depth - getPixelDepth(-1.0, 0.0));
            		depthDiff += abs(depth - getPixelDepth(0.0, 1.0));
            		depthDiff += abs(depth - getPixelDepth(0.0, -1.0));
            		// Get the difference between normals of neighboring pixels and current
            		float normalDiff = 0.0;
            		normalDiff += distance(normal, getPixelNormal(1, 0));
            		normalDiff += distance(normal, getPixelNormal(0, 1));
            		normalDiff += distance(normal, getPixelNormal(0, 1));
            		normalDiff += distance(normal, getPixelNormal(0, -1));
            		normalDiff += distance(normal, getPixelNormal(1, 1));
            		normalDiff += distance(normal, getPixelNormal(1, -1));
            		normalDiff += distance(normal, getPixelNormal(-1, 1));
            		normalDiff += distance(normal, getPixelNormal(-1, -1));
            		// Apply multiplier & bias to each
            		float depthBias = multiplierParameters.x;
            		float depthMultiplier = multiplierParameters.y;
            		float normalBias = multiplierParameters.z;
            		float normalMultiplier = multiplierParameters.w;
            		depthDiff = depthDiff * depthMultiplier;
            		depthDiff = saturate(depthDiff);
            		depthDiff = pow(depthDiff, depthBias);
            		normalDiff = normalDiff * normalMultiplier;
            		normalDiff = saturate(normalDiff);
            		normalDiff = pow(normalDiff, normalBias);
            		float outline = normalDiff+depthDiff ;

            		// Combine outline with scene color.
            		vec4 outlineColor = vec4(outlineColor, 1.0);
            		gl_FragColor = vec4(mix(sceneColor, outlineColor, outline));

            	}
            	`;
                }

                createOutlinePostProcessMaterial() {
                    const size = Math.min(this.resolution.x, this.resolution.y);
                    return new THREE.ShaderMaterial({
                        uniforms: {
                            sceneColorBuffer: {},
                            depthBuffer: {},
                            normalBuffer: {},
                            outlineColor: { value: new THREE.Color(0x000000) },
                            //4 scalar values packed in one uniform: depth multiplier, depth bias, and same for normals.
                            multiplierParameters: {
                                value: new THREE.Vector4(0.6, 10, 2, 0.5),
                            },
                            cameraNear: { value: this.renderCamera.near },
                            cameraFar: { value: this.renderCamera.far },
                            screenSize: {
                                value: new THREE.Vector4(
                                    2000,
                        2000,
                        1 / 2000,
                        1 / 2000
                                ),
                            },
                        },
                        vertexShader: this.vertexShader,
                        fragmentShader: this.fragmentShader,
                    });
                }
            }
            var canvas = document.getElementById("canvas");

            var renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
            });
            // renderer.setPixelRatio(0.5);

            var scene = new THREE.Scene();
            scene.background = new THREE.Color(0.4, 0.4, 0.4);

            var sky = createSky();
            // scene.add(sky);

            var DEV_MAPBOX_API_KEY =
                "pk.eyJ1IjoidGVudG9uZSIsImEiOiJjazBwNHU4eDQwZzE4M2VzOGhibWY5NXo5In0.8xpF1DEcT6Y4000vNhjj1g";
            var DEV_HEREMAPS_APP_ID = "HqSchC7XT2PA9qCfxzFq";
            var DEV_HEREMAPS_APP_CODE = "5rob9QcZ70J-m18Er8-rIA";
            var DEV_BING_API_KEY =
                "AuViYD_FXGfc3dxc0pNa8ZEJxyZyPq1lwOLPCOydV3f0tlEVH-HKMgxZ9ilcRj-T";
            var DEV_MAPTILER_API_KEY = "B9bz5tIKxl4beipiIbR0";
            var OPEN_MAP_TILES_SERVER_MAP = "";

            var providers = [
                ["Vector OpenSteet Maps", new Geo.OpenStreetMapsProvider()],
                [
                    "Vector OpenTile Maps",
                    new Geo.OpenMapTilesProvider(OPEN_MAP_TILES_SERVER_MAP),
                ],
                [
                    "Vector Map Box",
                    new Geo.MapBoxProvider(
                        DEV_MAPBOX_API_KEY,
                        "mapbox/streets-v10",
                        Geo.MapBoxProvider.STYLE
                    ),
                ],
                [
                    "Vector Here Maps",
                    new Geo.HereMapsProvider(
                        DEV_HEREMAPS_APP_ID,
                        DEV_HEREMAPS_APP_CODE,
                        "base",
                        "normal.day"
                    ),
                ],
                [
                    "Vector Here Maps Night",
                    new Geo.HereMapsProvider(
                        DEV_HEREMAPS_APP_ID,
                        DEV_HEREMAPS_APP_CODE,
                        "base",
                        "normal.night"
                    ),
                ],
                [
                    "Vector Here Maps Terrain",
                    new Geo.HereMapsProvider(
                        DEV_HEREMAPS_APP_ID,
                        DEV_HEREMAPS_APP_CODE,
                        "aerial",
                        "terrain.day"
                    ),
                ],
                [
                    "Vector Bing Maps",
                    new Geo.BingMapsProvider(
                        DEV_BING_API_KEY,
                        Geo.BingMapsProvider.ROAD
                    ),
                ],
                [
                    "Vector Map Tiler Basic",
                    new Geo.MapTilerProvider(
                        DEV_MAPTILER_API_KEY,
                        "maps",
                        "basic",
                        "png"
                    ),
                ],
                [
                    "Vector Map Tiler Outdoor",
                    new Geo.MapTilerProvider(
                        DEV_MAPTILER_API_KEY,
                        "maps",
                        "outdoor",
                        "png"
                    ),
                ],
                [
                    "Satellite Map Box",
                    new Geo.MapBoxProvider(
                        DEV_MAPBOX_API_KEY,
                        "mapbox.satellite",
                        Geo.MapBoxProvider.MAP_ID,
                        "jpg70",
                        false
                    ),
                ],
                [
                    "Satellite Map Box Labels",
                    new Geo.MapBoxProvider(
                        DEV_MAPBOX_API_KEY,
                        "mapbox/satellite-streets-v10",
                        Geo.MapBoxProvider.STYLE,
                        "jpg70"
                    ),
                ],
                [
                    "Satellite Here Maps",
                    new Geo.HereMapsProvider(
                        DEV_HEREMAPS_APP_ID,
                        DEV_HEREMAPS_APP_CODE,
                        "aerial",
                        "satellite.day",
                        "jpg"
                    ),
                ],
                [
                    "Satellite Bing Maps",
                    new Geo.BingMapsProvider(
                        DEV_BING_API_KEY,
                        Geo.BingMapsProvider.AERIAL
                    ),
                ],
                [
                    "Satellite Maps Tiler Labels",
                    new Geo.MapTilerProvider(
                        DEV_MAPTILER_API_KEY,
                        "maps",
                        "hybrid",
                        "jpg"
                    ),
                ],
                [
                    "Satellite Maps Tiler",
                    new Geo.MapTilerProvider(
                        DEV_MAPTILER_API_KEY,
                        "tiles",
                        "satellite",
                        "jpg"
                    ),
                ],
                [
                    "Height Map Box",
                    new Geo.MapBoxProvider(
                        DEV_MAPBOX_API_KEY,
                        "mapbox.terrain-rgb",
                        Geo.MapBoxProvider.MAP_ID,
                        "pngraw"
                    ),
                ],
                [
                    "Height Map Tiler",
                    new Geo.MapTilerProvider(
                        DEV_MAPTILER_API_KEY,
                        "tiles",
                        "terrain-rgb",
                        "png"
                    ),
                ],
                [
                    "Debug Height Map Box",
                    new Geo.HeightDebugProvider(
                        new Geo.MapBoxProvider(
                            DEV_MAPBOX_API_KEY,
                            "mapbox.terrain-rgb",
                            Geo.MapBoxProvider.MAP_ID,
                            "pngraw"
                        )
                    ),
                ],
                ["Debug", new Geo.DebugProvider()],
            ];

            var modes = [
                ["Planar", Geo.MapView.PLANAR],
                ["Height", Geo.MapView.HEIGHT],
                ["Height Shader", Geo.MapView.HEIGHT_SHADER],
                ["Spherical", Geo.MapView.SPHERICAL],
            ];

            var lods = [
                ["Raycast", Geo.LODRaycast],
                ["Frustum", Geo.LODFrustum],
                ["Radial", Geo.LODRadial],
            ];

            var lod = document.getElementById("lod");
            lod.onchange = function (event) {
                if (map !== undefined) {
                    map.lod = new lods[lod.selectedIndex][1]();
                }
            };
            for (var i = 0; i < lods.length; i++) {
                var option = document.createElement("option");
                option.innerHTML = lods[i][0];
                lod.appendChild(option);
            }

            var mode = document.getElementById("mode");
            mode.onchange = function (event) {
                if (map !== undefined) {
                    scene.remove(map);

                    map = new Geo.MapView(
                        modes[mode.selectedIndex][1],
                        providers[providerColor.selectedIndex][1],
                        providers[providerHeight.selectedIndex][1]
                    );
                    scene.add(map);
                }
            };
            for (var i = 0; i < modes.length; i++) {
                var option = document.createElement("option");
                option.innerHTML = modes[i][0];
                mode.appendChild(option);
            }

            var providerColor = document.getElementById("providerColor");
            providerColor.onchange = function (event) {
                if (map !== undefined) {
                    map.setProvider(providers[event.target.selectedIndex][1]);
                }
            };
            for (var i = 0; i < providers.length; i++) {
                var option = document.createElement("option");
                option.innerHTML = providers[i][0];
                providerColor.appendChild(option);
            }

            var providerHeight = document.getElementById("providerHeight");

            providerHeight.onchange = function (event) {
                if (map !== undefined) {
                    map.setHeightProvider(
                        providers[event.target.selectedIndex][1]
                    );
                }
            };
            for (var i = 0; i < providers.length; i++) {
                var option = document.createElement("option");
                option.innerHTML = providers[i][0];
                providerHeight.appendChild(option);
            }

            mode.selectedIndex = 2;
            providerColor.selectedIndex = 9;
            providerHeight.selectedIndex = 15;

            class EmptyProvider extends Geo.MapProvider {
                constructor() {
                    super();
                    this.name = "local";
                    this.minZoom = 0;
                    this.maxZoom = 20;
                }
                fetchTile(zoom, x, y) {
                    return Promise.resolve();
                }
            }
            class LocalHeightProvider extends Geo.MapProvider {
                constructor() {
                    super();
                    this.name = "local";
                    this.minZoom = 5;
                    this.maxZoom = 11;
                }
                fetchTile(zoom, x, y) {
                    return new Geo.CancelablePromise((resolve, reject) => {
                        var image = document.createElement("img");
                        image.onload = function () {
                            resolve(image);
                        };
                        image.onerror = function () {
                            reject();
                        };
                        image.crossOrigin = "Anonymous";
                        image.src =
                            "http://192.168.1.45:8080/data/BDALTIV2_75M_rvb/" +
                            // "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/" +
                            zoom +
                            "/" +
                            x +
                            "/" +
                            y +
                            ".png";
                        // console.log('fetchTile', image.src)
                    });
                }
            }

            class MaterialHeightShader extends Geo.MapHeightNode {
                /**
                 * Empty texture used as a placeholder for missing textures.
                 *
                 * @static
                 * @attribute EMPTY_TEXTURE
                 * @type {Texture}
                 */
                static EMPTY_TEXTURE = new THREE.Texture();

                /**
                 * Size of the grid of the geometry displayed on the scene for each tile.
                 *
                 * @static
                 * @attribute GEOMETRY_SIZE
                 * @type {number}
                 */
                static GEOMETRY_SIZE = 256;

                /**
                 * Map node plane geometry.
                 *
                 * @static
                 * @attribute GEOMETRY
                 * @type {PlaneBufferGeometry}
                 */
                static GEOMETRY = new Geo.MapNodeGeometry(
                    1,
                    1,
                    MaterialHeightShader.GEOMETRY_SIZE,
                    MaterialHeightShader.GEOMETRY_SIZE
                );
                static geometries = {};
                static getGeometry(level) {
					// if (level === 11 ){
					// 	return MaterialHeightShader.GEOMETRY
					// }
					// return undefined
                    let geo = MaterialHeightShader.geometries[level];
                    if (!MaterialHeightShader.geometries[level]) {
                        let size = MaterialHeightShader.GEOMETRY_SIZE;
                        if (level < 11) {
                            size /=  Math.pow(2, 11 - level) ;
							size = Math.max(16, size)
                        }
                        geo = MaterialHeightShader.geometries[
                            level
                        ] = new Geo.MapNodeGeometry(1, 1, size, size);
                    }
                    return geo;
                }

                constructor(parentNode, mapView, location, level, x, y) {
                    var material = new THREE.MeshPhongMaterial({
                        map: MaterialHeightShader.EMPTY_TEXTURE,
						color:0xffffff
                        // wireframe: true,
                    });
                    material = MaterialHeightShader.prepareMaterial(
                        material,
                        level
                    );
                    super(
                        parentNode,
                        mapView,
                        location,
                        level,
                        x,
                        y,
                        material,
                        MaterialHeightShader.getGeometry(level)
                    );

                    this.frustumCulled = false;
                }
                static prepareMaterial(material, level) {
                    material.userData = {
                        heightMap: {
                            value: MaterialHeightShader.EMPTY_TEXTURE,
                        },
                        drawNormals: {
                            value: 1,
                        },
                        zoomlevel: {
                            value: level,
                        },
                        exageration: {
                            value: 1.4,
                        },
                    };

                    material.onBeforeCompile = (shader) => {
                        // Pass uniforms from userData to the
                        for (let i in material.userData) {
                            shader.uniforms[i] = material.userData[i];
                        }
                        // Vertex variables
                        shader.vertexShader =
                            `
            		uniform bool drawNormals;
            		uniform float exageration;
            		uniform float zoomlevel;
            		uniform sampler2D heightMap;
            		float getElevation(vec2 coord, float bias) {
            			// Convert encoded elevation value to meters
            			vec4 e = texture2D(heightMap, clamp(coord, 0.0, 1.0));
            			return (((e.r * 255.0 * 65536.0 + e.g * 255.0 * 256.0 + e.b * 255.0) * 0.1) - 10000.0) * exageration;
            			// return ((e.r * 255.0 * 256.0 + e.g  * 255.0+ e.b * 255.0 / 256.0) - 32768.0) * exageration;
            		}
            		` + shader.vertexShader;
                        shader.fragmentShader =
                            `
            		uniform bool drawNormals;
            		` + shader.fragmentShader;

                        // Vertex depth logic
                        shader.fragmentShader = shader.fragmentShader.replace(
                            "#include <dithering_fragment>",
                            `
            			if(drawNormals) {
            				gl_FragColor = vec4( ( 0.5 * vNormal + 0.5 ), 1.0 );
            			}
            			`
                        );
                        shader.vertexShader = shader.vertexShader.replace(
                            "#include <fog_vertex>",
                            `
            			#include <fog_vertex>

            			// queried pixels:
            			// +-----------+
            			// |   |   |   |
            			// | a | b | c |
            			// |   |   |   |
            			// +-----------+
            			// |   |   |   |
            			// | d | e | f |
            			// |   |   |   |
            			// +-----------+
            			// |   |   |   |
            			// | g | h | i |
            			// |   |   |   |
            			// +-----------+

            			// vec4 theight = texture2D(heightMap, vUv);
            			float e = getElevation(vUv, 0.0);
            			if (drawNormals) {
            				ivec2 size = textureSize(heightMap, 0);
            				float offset = 1.0 / float(size.x);
            				float a = getElevation(vUv + vec2(-offset, -offset), 0.0);
            				float b = getElevation(vUv + vec2(0, -offset), 0.0);
            				float c = getElevation(vUv + vec2(offset, -offset), 0.0);
            				float d = getElevation(vUv + vec2(-offset, 0), 0.0);
            				float f = getElevation(vUv + vec2(offset, 0), 0.0);
            				float g = getElevation(vUv + vec2(-offset, offset), 0.0);
            				float h = getElevation(vUv + vec2(0, offset), 0.0);
            				float i = getElevation(vUv + vec2(offset,offset), 0.0);

            				float NormalLength = 500.0 / zoomlevel;

            				vec3 v0 = vec3(0.0, 0.0, 0.0);
            				vec3 v1 = vec3(0.0, NormalLength, 0.0);
            				vec3 v2 = vec3(NormalLength, 0.0, 0.0);
            				v0.z = (e + d + g + h) / 4.0;
            				v1.z = (e+ b + a + d) / 4.0;
            				v2.z = (e+ h + i + f) / 4.0;
            				vNormal = (normalize(cross(v2 - v0, v1 - v0)));
            			}

            			vec3 _transformed = position + e * normal;
            			vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );

            			gl_Position = projectionMatrix * modelViewMatrix * vec4(_transformed, 1.0);
            			`
                        );
                    };

                    return material;
                }
                loadTexture() {
                    var self = this;

                    this.mapView
                        .fetchTile(this.level, this.x, this.y)
                        .then(function (image) {
                            if (image) {
                                var texture = new THREE.Texture(image);
                                texture.generateMipmaps = false;
                                texture.format = THREE.RGBFormat;
                                texture.magFilter = THREE.LinearFilter;
                                texture.minFilter = THREE.LinearFilter;
                                texture.needsUpdate = true;

                                self.material.map = texture;
                            }

                            self.textureLoaded = true;
                            self.nodeReady();
                        })
                        .catch(function (err) {
                            console.error(
                                "GeoThree: Failed to load color node data.",
                                err
                            );
                            self.textureLoaded = true;
                            self.nodeReady();
                        });

                    this.loadHeightGeometry();
                }

                loadHeightGeometry() {
                    if (this.mapView.heightProvider === null) {
                        throw new Error(
                            "GeoThree: MapView.heightProvider provider is null."
                        );
                    }

                    var self = this;

                    // console.log('loadHeightGeometry', this.level, this.x, this.y)
                    this.mapView.heightProvider
                        .fetchTile(this.level, this.x, this.y)
                        .then(function (image) {
                            var texture = new THREE.Texture(image);
                            texture.generateMipmaps = false;
                            texture.format = THREE.RGBFormat;
                            texture.magFilter = THREE.NearestFilter;
                            texture.minFilter = THREE.NearestFilter;
                            texture.needsUpdate = true;

                            self.material.userData.heightMap.value = texture;

                            self.heightLoaded = true;
                            self.nodeReady();
                        })
                        .catch(function (err) {
                            console.error(
                                "GeoThree: Failed to load height node data.",
                                err
                            );
                            self.heightLoaded = true;
                            self.nodeReady();
                        });
                }

                /**
                 * Overrides normal raycasting, to avoid raycasting when isMesh is set to false.
                 *
                 * Switches the geometry for a simpler one for faster raycasting.
                 *
                 * @method raycast
                 */
                raycast(raycaster, intersects) {
                    if (this.isMesh === true) {
						const oldGeometry = this.geometry;
                        this.geometry = Geo.MapPlaneNode.GEOMETRY;

                        var result = THREE.Mesh.prototype.raycast.call(
                            this,
                            raycaster,
                            intersects
                        );

                        this.geometry = oldGeometry;

                        return result;
                    }

                    return false;
                }
            }

            var map = new Geo.MapView(
                null,
                // new Geo.DebugProvider(),
                new EmptyProvider(),
                new LocalHeightProvider()
            );
			map.lod = new Geo.LODFrustum();
			map.lod.subdivideDistance = 40;
	
			map.lod.simplifyDistance = 140;
            map.scale.set(
                Geo.UnitsUtils.EARTH_PERIMETER,
                Geo.MapHeightNode.USE_DISPLACEMENT
                    ? Geo.MapHeightNode.MAX_HEIGHT
                    : 1,
                Geo.UnitsUtils.EARTH_PERIMETER
            );
            map.root = new MaterialHeightShader(
                null,
                map,
                Geo.MapNode.ROOT,
                0,
                0,
                0
            );
            map.mode = Geo.MapView.HEIGHT_SHADER;
			// map.lod.subdivisionRays = 2;
			// map.lod.thresholdUp = 0.9;
			// map.lod.thresholdDown = 0.5;
            map.add(map.root);
            scene.add(map);
            map.updateMatrixWorld(true);

            var camera = new THREE.PerspectiveCamera(80, 1, 100, 100000);

            var controls = new THREE.MapControls(camera, canvas);
			// controls.screenSpacePanning = true;
// 			controls.keys = {
// 	LEFT: 'ArrowLeft', //left arrow
// 	UP: 'ArrowUp', // up arrow
// 	RIGHT: 'ArrowRight', // right arrow
// 	BOTTOM: 'ArrowDown' // down arrow
// }
            controls.enableZoom = false;
            controls.minDistance = 00;
            controls.maxDistance =100;
            // controls.minPolarAngle = Math.PI / 3;
            // controls.maxPolarAngle = Math.PI / 2.01;
            controls.zoomSpeed = -20.0;
            controls.minZoom = 100.0;
            controls.panSpeed = 60.0;
			controls.mouseButtons = {
	LEFT: THREE.MOUSE.ROTATE,
	MIDDLE: THREE.MOUSE.DOLLY,
	RIGHT: THREE.MOUSE.PAN
}

            var coords = Geo.UnitsUtils.datumsToSpherical(45.16667,5.71667);
            controls.target.set(coords.x, 1000, -coords.y);
            scene.add(new THREE.AmbientLight(0x777777));

            var directional = new THREE.DirectionalLight(0x777777);
            directional.position.set(100, 10000, 700);
            scene.add(directional);

            const depthTexture = new THREE.DepthTexture();
            const renderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth,
                window.innerHeight,
                {
                    depthTexture,
                    depthBuffer: true,
                }
            );
            const composer = new THREE.EffectComposer(renderer, renderTarget);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            const customOutline = new CustomOutlinePass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                scene,
                camera
            );
            composer.addPass(customOutline);

            document.body.onresize = function () {
                var width = window.innerWidth;
                var height = window.innerHeight;
                renderer.setSize(width, height);
                composer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            };
            document.body.onresize();

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                // renderer.render(scene, camera);

                composer.render();
            }
            animate();

            function createSky() {
                // Add Sky
                var sky = new THREE.Sky();
                sky.scale.setScalar(1e8);

                // GUI
                var effectController = {
                    turbidity: 0,
                    rayleigh: 0.5,
                    mieCoefficient: 0.005,
                    mieDirectionalG: 0.7,
                    inclination: 0.48,
                    azimuth: 0.25,
                    exposure: 0.5,
                };

                const uniforms = sky.material.uniforms;
                uniforms["turbidity"].value = effectController.turbidity;
                uniforms["rayleigh"].value = effectController.rayleigh;
                uniforms["mieCoefficient"].value =
                    effectController.mieCoefficient;
                uniforms["mieDirectionalG"].value =
                    effectController.mieDirectionalG;

                var theta = Math.PI * (effectController.inclination - 0.5);
                var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

                var sun = new THREE.Vector3();
                sun.x = Math.cos(phi);
                sun.y = Math.sin(phi) * Math.sin(theta);
                sun.z = Math.sin(phi) * Math.cos(theta);
                uniforms["sunPosition"].value.copy(sun);

                return sky;
            }
        </script>
    </body>
</html>
